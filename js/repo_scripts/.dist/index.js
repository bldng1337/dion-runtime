// @bun
import{copyFile as T,exists as N,readdir as V}from"fs/promises";import{join as I}from"path";import{valibot as W}from"@dion-js/runtime-types/extension";var{$:X,file:O}=globalThis.Bun;import*as H from"valibot";import{valibot as J}from"@dion-js/runtime-types/extension";var{$:R,file:K}=globalThis.Bun;import*as C from"valibot";async function S(w){let z,B;try{z=(await R`git config --get remote.origin.url`.quiet()).stdout.toString().trim()}catch(q){B=q}let D=C.parse(C.omit(J.DionRepoIndex,["repo_index_version","content"]),await K(w?.repoIndexPath??"../../package.json").json());if(D.url!==void 0)return D.url;if(B!==void 0){console.error(`Failed to get Repo URL from git config: ${B}`);return}return z}async function L(w){let z=C.parse(C.omit(J.ExtensionMetadata,["repo"]),await K(w?.extensionPath??"./package.json").json());if(w?.repoUrl===void 0)return{...z,repo:await S({repoIndexPath:w?.repoIndexPath})};return{...z,repo:w?.repoUrl}}async function Y(){let[z]=await Promise.all([V("./extensions"),X`rm -rf ${".index"} && mkdir ${".index"}`]);await Promise.all(z.map(async(q)=>{let E=I(".index",`${q}.dion.js`),A=I("extensions",q,".dist",`${q}.dion.js`);if(!await N(A)){console.warn(`Source file does not exist: ${A}, skipping.`);return}console.log(`Copying ${A} to ${E}`),await T(A,E)}));let B=H.parse(H.omit(W.DionRepoIndex,["repo_index_version","content"]),await O("./package.json").json()),D=(await Promise.all(z.map(async(q)=>{let E=I(".index",`${q}.dion.js`);if(!await N(E))return;try{let A={repoIndexPath:"./package.json",extensionPath:`./extensions/${q}/package.json`,repoUrl:B.url},Q=await L(A);return{path:`${q}.dion.js`,extdata:Q}}catch(A){console.error(`Failed to parse package.json for extension ${q}:`,A);return}}))).filter((q)=>q!==void 0);await O(".index/index.repo.json").write(JSON.stringify({repo_index_version:1,content:D,...B}))}Y().catch((w)=>{console.error("Failed to build index"),console.error(w.message),console.error(w.stack),console.error(w),process.exit(1)});
