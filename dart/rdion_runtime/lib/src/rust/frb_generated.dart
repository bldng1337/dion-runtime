// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

import 'dart:convert';

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/cancel.dart';
import 'api/client.dart';
import 'api/extension.dart';
import 'dart:async';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'third_party/dion_runtime/data/action.dart';
import 'third_party/dion_runtime/data/activity.dart';
import 'third_party/dion_runtime/data/auth.dart';
import 'third_party/dion_runtime/data/custom_ui.dart';
import 'third_party/dion_runtime/data/extension.dart';
import 'third_party/dion_runtime/data/extension_manager.dart';
import 'third_party/dion_runtime/data/extension_repo.dart';
import 'third_party/dion_runtime/data/permission.dart';
import 'third_party/dion_runtime/data/settings.dart';
import 'third_party/dion_runtime/data/source.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiLetsInitAppHere();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 859095815;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rdion_runtime',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiCancelCancelTokenCancel({required CancelToken that});

  Future<CancelToken> crateApiCancelCancelTokenGetChild(
      {required CancelToken that});

  Future<bool> crateApiCancelCancelTokenIsCancelled(
      {required CancelToken that});

  CancelToken crateApiCancelCancelTokenNew();

  Future<ExtensionClient> crateApiClientExtensionClientInit(
      {required FutureOr<String> Function(String) loadData,
      required FutureOr<void> Function(String, String) storeData,
      required FutureOr<String> Function(String) loadDataSecure,
      required FutureOr<void> Function(String, String) storeDataSecure,
      required FutureOr<void> Function(Action) doAction,
      required FutureOr<bool> Function(Permission, String?) requestPermission,
      required FutureOr<String> Function() getPath,
      required FutureOr<void> Function(EntryId, String, SettingValue)
          setEntrySetting});

  Future<ManagerClient> crateApiClientManagerClientInit(
      {required FutureOr<String> Function() getPath,
      required FutureOr<ExtensionClient> Function(ExtensionData) getClient});

  Future<RemoteExtensionResult> crateApiExtensionProxyAdapterBrowseRepo(
      {required ProxyAdapter that,
      required ExtensionRepo repo,
      required int page});

  Future<List<ProxyExtension>> crateApiExtensionProxyAdapterGetExtensions(
      {required ProxyAdapter that});

  Future<ExtensionRepo> crateApiExtensionProxyAdapterGetRepo(
      {required ProxyAdapter that, required String url});

  Future<ProxyAdapter> crateApiExtensionProxyAdapterInitDion(
      {required ManagerClient client});

  Future<ProxyExtension> crateApiExtensionProxyAdapterInstall(
      {required ProxyAdapter that, required String location});

  Future<void> crateApiExtensionProxyAdapterUninstall(
      {required ProxyAdapter that, required ProxyExtension ext});

  Future<EntryList> crateApiExtensionProxyExtensionBrowse(
      {required ProxyExtension that, required int page, CancelToken? token});

  Future<EntryDetailedResult> crateApiExtensionProxyExtensionDetail(
      {required ProxyExtension that,
      required EntryId entryid,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<EventResult?> crateApiExtensionProxyExtensionEvent(
      {required ProxyExtension that,
      required EventData event,
      CancelToken? token});

  Future<List<Account>> crateApiExtensionProxyExtensionGetAccounts(
      {required ProxyExtension that});

  Future<ExtensionData> crateApiExtensionProxyExtensionGetExtensionData(
      {required ProxyExtension that});

  Future<List<Permission>> crateApiExtensionProxyExtensionGetPermissions(
      {required ProxyExtension that});

  Future<Setting> crateApiExtensionProxyExtensionGetSetting(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind});

  Future<List<String>> crateApiExtensionProxyExtensionGetSettingIds(
      {required ProxyExtension that, required SettingKind kind});

  Future<Map<String, Setting>> crateApiExtensionProxyExtensionGetSettings(
      {required ProxyExtension that, required SettingKind kind});

  Future<bool> crateApiExtensionProxyExtensionHandleUrl(
      {required ProxyExtension that, required String url, CancelToken? token});

  Future<bool> crateApiExtensionProxyExtensionHasPermission(
      {required ProxyExtension that, required Permission permission});

  Future<void> crateApiExtensionProxyExtensionInvalidate(
      {required ProxyExtension that, required String domain});

  Future<bool> crateApiExtensionProxyExtensionIsEnabled(
      {required ProxyExtension that});

  Future<bool> crateApiExtensionProxyExtensionIsLoggedIn(
      {required ProxyExtension that, required String domain});

  Future<EntryDetailedResult> crateApiExtensionProxyExtensionMapEntry(
      {required ProxyExtension that,
      required EntryDetailed entry,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<SourceResult> crateApiExtensionProxyExtensionMapSource(
      {required ProxyExtension that,
      required Source source,
      required EpisodeId epid,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<void> crateApiExtensionProxyExtensionMergeAuth(
      {required ProxyExtension that, required Account account});

  Future<void> crateApiExtensionProxyExtensionMergeSettingDefinition(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind,
      required Setting definition});

  Future<void> crateApiExtensionProxyExtensionOnEntryActivity(
      {required ProxyExtension that,
      required EntryActivity activity,
      required EntryDetailed entry,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<void> crateApiExtensionProxyExtensionReload(
      {required ProxyExtension that});

  Future<void> crateApiExtensionProxyExtensionRemovePermission(
      {required ProxyExtension that, required Permission permission});

  Future<void> crateApiExtensionProxyExtensionRemoveSetting(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind});

  Future<void> crateApiExtensionProxyExtensionSaveAuthState(
      {required ProxyExtension that});

  Future<void> crateApiExtensionProxyExtensionSavePermissions(
      {required ProxyExtension that});

  Future<void> crateApiExtensionProxyExtensionSaveSettings(
      {required ProxyExtension that});

  Future<EntryList> crateApiExtensionProxyExtensionSearch(
      {required ProxyExtension that,
      required int page,
      required String filter,
      CancelToken? token});

  Future<void> crateApiExtensionProxyExtensionSetEnabled(
      {required ProxyExtension that, required bool enabled});

  Future<void> crateApiExtensionProxyExtensionSetSetting(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind,
      required SettingValue value});

  Future<SourceResult> crateApiExtensionProxyExtensionSource(
      {required ProxyExtension that,
      required EpisodeId epid,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<Account?> crateApiExtensionProxyExtensionValidate(
      {required ProxyExtension that,
      required Account account,
      CancelToken? token});

  Future<EntryList> dionRuntimeDataSourceEntryListDefault();

  Future<ExtensionData> dionRuntimeDataExtensionExtensionDataDefault();

  Future<ExtensionManagerData>
      dionRuntimeDataExtensionManagerExtensionManagerDataDefault();

  Future<ExtensionRepo> dionRuntimeDataExtensionRepoExtensionRepoDefault();

  Future<void> crateApiLetsInitAppHere();

  Future<Link> dionRuntimeDataSourceLinkDefault();

  Future<MediaType> dionRuntimeDataSourceMediaTypeDefault();

  Future<ReleaseStatus> dionRuntimeDataSourceReleaseStatusDefault();

  Future<RemoteExtension> dionRuntimeDataExtensionRepoRemoteExtensionDefault();

  Future<RemoteExtensionResult>
      dionRuntimeDataExtensionRepoRemoteExtensionResultDefault();

  Future<SourceOpenType> dionRuntimeDataExtensionSourceOpenTypeDefault();

  Future<TimestampType> dionRuntimeDataCustomUiTimestampTypeDefault();

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_CancelToken;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_CancelToken;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_CancelTokenPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExtensionClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExtensionClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ExtensionClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ManagerClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ManagerClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ManagerClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProxyAdapter;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProxyAdapter;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ProxyAdapterPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProxyExtension;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProxyExtension;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ProxyExtensionPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiCancelCancelTokenCancel({required CancelToken that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
                that);
        return wire.wire__crate__api__cancel__CancelToken_cancel(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCancelCancelTokenCancelConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCancelCancelTokenCancelConstMeta =>
      const TaskConstMeta(
        debugName: "CancelToken_cancel",
        argNames: ["that"],
      );

  @override
  Future<CancelToken> crateApiCancelCancelTokenGetChild(
      {required CancelToken that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
                that);
        return wire.wire__crate__api__cancel__CancelToken_get_child(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCancelCancelTokenGetChildConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCancelCancelTokenGetChildConstMeta =>
      const TaskConstMeta(
        debugName: "CancelToken_get_child",
        argNames: ["that"],
      );

  @override
  Future<bool> crateApiCancelCancelTokenIsCancelled(
      {required CancelToken that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
                that);
        return wire.wire__crate__api__cancel__CancelToken_is_cancelled(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCancelCancelTokenIsCancelledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCancelCancelTokenIsCancelledConstMeta =>
      const TaskConstMeta(
        debugName: "CancelToken_is_cancelled",
        argNames: ["that"],
      );

  @override
  CancelToken crateApiCancelCancelTokenNew() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        return wire.wire__crate__api__cancel__CancelToken_new();
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCancelCancelTokenNewConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCancelCancelTokenNewConstMeta =>
      const TaskConstMeta(
        debugName: "CancelToken_new",
        argNames: [],
      );

  @override
  Future<ExtensionClient> crateApiClientExtensionClientInit(
      {required FutureOr<String> Function(String) loadData,
      required FutureOr<void> Function(String, String) storeData,
      required FutureOr<String> Function(String) loadDataSecure,
      required FutureOr<void> Function(String, String) storeDataSecure,
      required FutureOr<void> Function(Action) doAction,
      required FutureOr<bool> Function(Permission, String?) requestPermission,
      required FutureOr<String> Function() getPath,
      required FutureOr<void> Function(EntryId, String, SettingValue)
          setEntrySetting}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_DartFn_Inputs_String_Output_String_AnyhowException(
            loadData, serializer);
        sse_encode_DartFn_Inputs_String_String_Output_unit_AnyhowException(
            storeData, serializer);
        sse_encode_DartFn_Inputs_String_Output_String_AnyhowException(
            loadDataSecure, serializer);
        sse_encode_DartFn_Inputs_String_String_Output_unit_AnyhowException(
            storeDataSecure, serializer);
        sse_encode_DartFn_Inputs_action_Output_unit_AnyhowException(
            doAction, serializer);
        sse_encode_DartFn_Inputs_permission_opt_String_Output_bool_AnyhowException(
            requestPermission, serializer);
        sse_encode_DartFn_Inputs__Output_String_AnyhowException(
            getPath, serializer);
        sse_encode_DartFn_Inputs_entry_id_String_setting_value_Output_unit_AnyhowException(
            setEntrySetting, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__client__ExtensionClient_init(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiClientExtensionClientInitConstMeta,
      argValues: [
        loadData,
        storeData,
        loadDataSecure,
        storeDataSecure,
        doAction,
        requestPermission,
        getPath,
        setEntrySetting
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiClientExtensionClientInitConstMeta =>
      const TaskConstMeta(
        debugName: "ExtensionClient_init",
        argNames: [
          "loadData",
          "storeData",
          "loadDataSecure",
          "storeDataSecure",
          "doAction",
          "requestPermission",
          "getPath",
          "setEntrySetting"
        ],
      );

  @override
  Future<ManagerClient> crateApiClientManagerClientInit(
      {required FutureOr<String> Function() getPath,
      required FutureOr<ExtensionClient> Function(ExtensionData) getClient}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_DartFn_Inputs__Output_String_AnyhowException(
            getPath, serializer);
        sse_encode_DartFn_Inputs_extension_data_Output_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient_AnyhowException(
            getClient, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__client__ManagerClient_init(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiClientManagerClientInitConstMeta,
      argValues: [getPath, getClient],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiClientManagerClientInitConstMeta =>
      const TaskConstMeta(
        debugName: "ManagerClient_init",
        argNames: ["getPath", "getClient"],
      );

  @override
  Future<RemoteExtensionResult> crateApiExtensionProxyAdapterBrowseRepo(
      {required ProxyAdapter that,
      required ExtensionRepo repo,
      required int page}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
                that);
        var arg1 = cst_encode_box_autoadd_extension_repo(repo);
        var arg2 = cst_encode_i_32(page);
        return wire.wire__crate__api__extension__ProxyAdapter_browse_repo(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_remote_extension_result,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyAdapterBrowseRepoConstMeta,
      argValues: [that, repo, page],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyAdapterBrowseRepoConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyAdapter_browse_repo",
        argNames: ["that", "repo", "page"],
      );

  @override
  Future<List<ProxyExtension>> crateApiExtensionProxyAdapterGetExtensions(
      {required ProxyAdapter that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
                that);
        return wire.wire__crate__api__extension__ProxyAdapter_get_extensions(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyAdapterGetExtensionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyAdapterGetExtensionsConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyAdapter_get_extensions",
        argNames: ["that"],
      );

  @override
  Future<ExtensionRepo> crateApiExtensionProxyAdapterGetRepo(
      {required ProxyAdapter that, required String url}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
                that);
        var arg1 = cst_encode_String(url);
        return wire.wire__crate__api__extension__ProxyAdapter_get_repo(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_extension_repo,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyAdapterGetRepoConstMeta,
      argValues: [that, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyAdapterGetRepoConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyAdapter_get_repo",
        argNames: ["that", "url"],
      );

  @override
  Future<ProxyAdapter> crateApiExtensionProxyAdapterInitDion(
      {required ManagerClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
                client);
        return wire.wire__crate__api__extension__ProxyAdapter_init_dion(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyAdapterInitDionConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyAdapterInitDionConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyAdapter_init_dion",
        argNames: ["client"],
      );

  @override
  Future<ProxyExtension> crateApiExtensionProxyAdapterInstall(
      {required ProxyAdapter that, required String location}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
                that);
        var arg1 = cst_encode_String(location);
        return wire.wire__crate__api__extension__ProxyAdapter_install(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyAdapterInstallConstMeta,
      argValues: [that, location],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyAdapterInstallConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyAdapter_install",
        argNames: ["that", "location"],
      );

  @override
  Future<void> crateApiExtensionProxyAdapterUninstall(
      {required ProxyAdapter that, required ProxyExtension ext}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
                that);
        var arg1 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                ext);
        return wire.wire__crate__api__extension__ProxyAdapter_uninstall(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyAdapterUninstallConstMeta,
      argValues: [that, ext],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyAdapterUninstallConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyAdapter_uninstall",
        argNames: ["that", "ext"],
      );

  @override
  Future<EntryList> crateApiExtensionProxyExtensionBrowse(
      {required ProxyExtension that, required int page, CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_i_32(page, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_browse(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_entry_list,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionBrowseConstMeta,
      argValues: [that, page, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionBrowseConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_browse",
        argNames: ["that", "page", "token"],
      );

  @override
  Future<EntryDetailedResult> crateApiExtensionProxyExtensionDetail(
      {required ProxyExtension that,
      required EntryId entryid,
      required Map<String, Setting> settings,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_entry_id(entryid, serializer);
        sse_encode_Map_String_setting_None(settings, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_detail(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_entry_detailed_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionDetailConstMeta,
      argValues: [that, entryid, settings, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionDetailConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_detail",
        argNames: ["that", "entryid", "settings", "token"],
      );

  @override
  Future<EventResult?> crateApiExtensionProxyExtensionEvent(
      {required ProxyExtension that,
      required EventData event,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_event_data(event, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_event(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_event_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionEventConstMeta,
      argValues: [that, event, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionEventConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_event",
        argNames: ["that", "event", "token"],
      );

  @override
  Future<List<Account>> crateApiExtensionProxyExtensionGetAccounts(
      {required ProxyExtension that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_get_accounts(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_account,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiExtensionProxyExtensionGetAccountsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionGetAccountsConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_get_accounts",
        argNames: ["that"],
      );

  @override
  Future<ExtensionData> crateApiExtensionProxyExtensionGetExtensionData(
      {required ProxyExtension that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        final raw_ = serializer.intoRaw();
        return wire
            .wire__crate__api__extension__ProxyExtension_get_extension_data(
                port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_extension_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionGetExtensionDataConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionGetExtensionDataConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_get_extension_data",
        argNames: ["that"],
      );

  @override
  Future<List<Permission>> crateApiExtensionProxyExtensionGetPermissions(
      {required ProxyExtension that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_get_permissions(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_permission,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionGetPermissionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionGetPermissionsConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_get_permissions",
        argNames: ["that"],
      );

  @override
  Future<Setting> crateApiExtensionProxyExtensionGetSetting(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_String(id, serializer);
        sse_encode_setting_kind(kind, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_get_setting(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_setting,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionGetSettingConstMeta,
      argValues: [that, id, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionGetSettingConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_get_setting",
        argNames: ["that", "id", "kind"],
      );

  @override
  Future<List<String>> crateApiExtensionProxyExtensionGetSettingIds(
      {required ProxyExtension that, required SettingKind kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_setting_kind(kind, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_get_setting_ids(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiExtensionProxyExtensionGetSettingIdsConstMeta,
      argValues: [that, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionGetSettingIdsConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_get_setting_ids",
        argNames: ["that", "kind"],
      );

  @override
  Future<Map<String, Setting>> crateApiExtensionProxyExtensionGetSettings(
      {required ProxyExtension that, required SettingKind kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_setting_kind(kind, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_get_settings(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Map_String_setting_None,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionGetSettingsConstMeta,
      argValues: [that, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionGetSettingsConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_get_settings",
        argNames: ["that", "kind"],
      );

  @override
  Future<bool> crateApiExtensionProxyExtensionHandleUrl(
      {required ProxyExtension that, required String url, CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        var arg1 = cst_encode_String(url);
        var arg2 =
            cst_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
                token);
        return wire.wire__crate__api__extension__ProxyExtension_handle_url(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionHandleUrlConstMeta,
      argValues: [that, url, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionHandleUrlConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_handle_url",
        argNames: ["that", "url", "token"],
      );

  @override
  Future<bool> crateApiExtensionProxyExtensionHasPermission(
      {required ProxyExtension that, required Permission permission}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_permission(permission, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_has_permission(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiExtensionProxyExtensionHasPermissionConstMeta,
      argValues: [that, permission],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionHasPermissionConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_has_permission",
        argNames: ["that", "permission"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionInvalidate(
      {required ProxyExtension that, required String domain}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        var arg1 = cst_encode_String(domain);
        return wire.wire__crate__api__extension__ProxyExtension_invalidate(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiExtensionProxyExtensionInvalidateConstMeta,
      argValues: [that, domain],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionInvalidateConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_invalidate",
        argNames: ["that", "domain"],
      );

  @override
  Future<bool> crateApiExtensionProxyExtensionIsEnabled(
      {required ProxyExtension that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        return wire.wire__crate__api__extension__ProxyExtension_is_enabled(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiExtensionProxyExtensionIsEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionIsEnabledConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_is_enabled",
        argNames: ["that"],
      );

  @override
  Future<bool> crateApiExtensionProxyExtensionIsLoggedIn(
      {required ProxyExtension that, required String domain}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        var arg1 = cst_encode_String(domain);
        return wire.wire__crate__api__extension__ProxyExtension_is_logged_in(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiExtensionProxyExtensionIsLoggedInConstMeta,
      argValues: [that, domain],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionIsLoggedInConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_is_logged_in",
        argNames: ["that", "domain"],
      );

  @override
  Future<EntryDetailedResult> crateApiExtensionProxyExtensionMapEntry(
      {required ProxyExtension that,
      required EntryDetailed entry,
      required Map<String, Setting> settings,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_entry_detailed(entry, serializer);
        sse_encode_Map_String_setting_None(settings, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_map_entry(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_entry_detailed_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionMapEntryConstMeta,
      argValues: [that, entry, settings, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionMapEntryConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_map_entry",
        argNames: ["that", "entry", "settings", "token"],
      );

  @override
  Future<SourceResult> crateApiExtensionProxyExtensionMapSource(
      {required ProxyExtension that,
      required Source source,
      required EpisodeId epid,
      required Map<String, Setting> settings,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_source(source, serializer);
        sse_encode_box_autoadd_episode_id(epid, serializer);
        sse_encode_Map_String_setting_None(settings, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_map_source(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_source_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionMapSourceConstMeta,
      argValues: [that, source, epid, settings, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionMapSourceConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_map_source",
        argNames: ["that", "source", "epid", "settings", "token"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionMergeAuth(
      {required ProxyExtension that, required Account account}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        var arg1 = cst_encode_box_autoadd_account(account);
        return wire.wire__crate__api__extension__ProxyExtension_merge_auth(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiExtensionProxyExtensionMergeAuthConstMeta,
      argValues: [that, account],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionMergeAuthConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_merge_auth",
        argNames: ["that", "account"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionMergeSettingDefinition(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind,
      required Setting definition}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_String(id, serializer);
        sse_encode_setting_kind(kind, serializer);
        sse_encode_box_autoadd_setting(definition, serializer);
        final raw_ = serializer.intoRaw();
        return wire
            .wire__crate__api__extension__ProxyExtension_merge_setting_definition(
                port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta:
          kCrateApiExtensionProxyExtensionMergeSettingDefinitionConstMeta,
      argValues: [that, id, kind, definition],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiExtensionProxyExtensionMergeSettingDefinitionConstMeta =>
          const TaskConstMeta(
            debugName: "ProxyExtension_merge_setting_definition",
            argNames: ["that", "id", "kind", "definition"],
          );

  @override
  Future<void> crateApiExtensionProxyExtensionOnEntryActivity(
      {required ProxyExtension that,
      required EntryActivity activity,
      required EntryDetailed entry,
      required Map<String, Setting> settings,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_entry_activity(activity, serializer);
        sse_encode_box_autoadd_entry_detailed(entry, serializer);
        sse_encode_Map_String_setting_None(settings, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire
            .wire__crate__api__extension__ProxyExtension_on_entry_activity(
                port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionOnEntryActivityConstMeta,
      argValues: [that, activity, entry, settings, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionOnEntryActivityConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_on_entry_activity",
        argNames: ["that", "activity", "entry", "settings", "token"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionReload(
      {required ProxyExtension that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        return wire.wire__crate__api__extension__ProxyExtension_reload(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionReloadConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionReloadConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_reload",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionRemovePermission(
      {required ProxyExtension that, required Permission permission}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_permission(permission, serializer);
        final raw_ = serializer.intoRaw();
        return wire
            .wire__crate__api__extension__ProxyExtension_remove_permission(
                port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionRemovePermissionConstMeta,
      argValues: [that, permission],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionRemovePermissionConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_remove_permission",
        argNames: ["that", "permission"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionRemoveSetting(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_String(id, serializer);
        sse_encode_setting_kind(kind, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_remove_setting(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionRemoveSettingConstMeta,
      argValues: [that, id, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionRemoveSettingConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_remove_setting",
        argNames: ["that", "id", "kind"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionSaveAuthState(
      {required ProxyExtension that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        return wire.wire__crate__api__extension__ProxyExtension_save_auth_state(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionSaveAuthStateConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionSaveAuthStateConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_save_auth_state",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionSavePermissions(
      {required ProxyExtension that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        return wire
            .wire__crate__api__extension__ProxyExtension_save_permissions(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionSavePermissionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionSavePermissionsConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_save_permissions",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionSaveSettings(
      {required ProxyExtension that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        return wire.wire__crate__api__extension__ProxyExtension_save_settings(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionSaveSettingsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionSaveSettingsConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_save_settings",
        argNames: ["that"],
      );

  @override
  Future<EntryList> crateApiExtensionProxyExtensionSearch(
      {required ProxyExtension that,
      required int page,
      required String filter,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_i_32(page, serializer);
        sse_encode_String(filter, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_search(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_entry_list,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionSearchConstMeta,
      argValues: [that, page, filter, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionSearchConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_search",
        argNames: ["that", "page", "filter", "token"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionSetEnabled(
      {required ProxyExtension that, required bool enabled}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        var arg1 = cst_encode_bool(enabled);
        return wire.wire__crate__api__extension__ProxyExtension_set_enabled(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionSetEnabledConstMeta,
      argValues: [that, enabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionSetEnabledConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_set_enabled",
        argNames: ["that", "enabled"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionSetSetting(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind,
      required SettingValue value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_String(id, serializer);
        sse_encode_setting_kind(kind, serializer);
        sse_encode_box_autoadd_setting_value(value, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_set_setting(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionSetSettingConstMeta,
      argValues: [that, id, kind, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionSetSettingConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_set_setting",
        argNames: ["that", "id", "kind", "value"],
      );

  @override
  Future<SourceResult> crateApiExtensionProxyExtensionSource(
      {required ProxyExtension that,
      required EpisodeId epid,
      required Map<String, Setting> settings,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_episode_id(epid, serializer);
        sse_encode_Map_String_setting_None(settings, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_source(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_source_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionSourceConstMeta,
      argValues: [that, epid, settings, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionSourceConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_source",
        argNames: ["that", "epid", "settings", "token"],
      );

  @override
  Future<Account?> crateApiExtensionProxyExtensionValidate(
      {required ProxyExtension that,
      required Account account,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_account(account, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_validate(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_account,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionValidateConstMeta,
      argValues: [that, account, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionValidateConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_validate",
        argNames: ["that", "account", "token"],
      );

  @override
  Future<EntryList> dionRuntimeDataSourceEntryListDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__dion_runtime__data__source__entry_list_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_entry_list,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDataSourceEntryListDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDataSourceEntryListDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "entry_list_default",
        argNames: [],
      );

  @override
  Future<ExtensionData> dionRuntimeDataExtensionExtensionDataDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__data__extension__extension_data_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_extension_data,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDataExtensionExtensionDataDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDataExtensionExtensionDataDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "extension_data_default",
        argNames: [],
      );

  @override
  Future<ExtensionManagerData>
      dionRuntimeDataExtensionManagerExtensionManagerDataDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__data__extension_manager__extension_manager_data_default(
                port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_extension_manager_data,
        decodeErrorData: null,
      ),
      constMeta:
          kDionRuntimeDataExtensionManagerExtensionManagerDataDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kDionRuntimeDataExtensionManagerExtensionManagerDataDefaultConstMeta =>
          const TaskConstMeta(
            debugName: "extension_manager_data_default",
            argNames: [],
          );

  @override
  Future<ExtensionRepo> dionRuntimeDataExtensionRepoExtensionRepoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__data__extension_repo__extension_repo_default(
                port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_extension_repo,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDataExtensionRepoExtensionRepoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kDionRuntimeDataExtensionRepoExtensionRepoDefaultConstMeta =>
          const TaskConstMeta(
            debugName: "extension_repo_default",
            argNames: [],
          );

  @override
  Future<void> crateApiLetsInitAppHere() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__lets_init_app_here(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiLetsInitAppHereConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLetsInitAppHereConstMeta => const TaskConstMeta(
        debugName: "lets_init_app_here",
        argNames: [],
      );

  @override
  Future<Link> dionRuntimeDataSourceLinkDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__dion_runtime__data__source__link_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_link,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDataSourceLinkDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDataSourceLinkDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "link_default",
        argNames: [],
      );

  @override
  Future<MediaType> dionRuntimeDataSourceMediaTypeDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__dion_runtime__data__source__media_type_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_media_type,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDataSourceMediaTypeDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDataSourceMediaTypeDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "media_type_default",
        argNames: [],
      );

  @override
  Future<ReleaseStatus> dionRuntimeDataSourceReleaseStatusDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__data__source__release_status_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_release_status,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDataSourceReleaseStatusDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDataSourceReleaseStatusDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "release_status_default",
        argNames: [],
      );

  @override
  Future<RemoteExtension> dionRuntimeDataExtensionRepoRemoteExtensionDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__data__extension_repo__remote_extension_default(
                port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_remote_extension,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDataExtensionRepoRemoteExtensionDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kDionRuntimeDataExtensionRepoRemoteExtensionDefaultConstMeta =>
          const TaskConstMeta(
            debugName: "remote_extension_default",
            argNames: [],
          );

  @override
  Future<RemoteExtensionResult>
      dionRuntimeDataExtensionRepoRemoteExtensionResultDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__data__extension_repo__remote_extension_result_default(
                port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_remote_extension_result,
        decodeErrorData: null,
      ),
      constMeta:
          kDionRuntimeDataExtensionRepoRemoteExtensionResultDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kDionRuntimeDataExtensionRepoRemoteExtensionResultDefaultConstMeta =>
          const TaskConstMeta(
            debugName: "remote_extension_result_default",
            argNames: [],
          );

  @override
  Future<SourceOpenType> dionRuntimeDataExtensionSourceOpenTypeDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__data__extension__source_open_type_default(
                port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_source_open_type,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDataExtensionSourceOpenTypeDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDataExtensionSourceOpenTypeDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "source_open_type_default",
        argNames: [],
      );

  @override
  Future<TimestampType> dionRuntimeDataCustomUiTimestampTypeDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__data__custom_ui__timestamp_type_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_timestamp_type,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDataCustomUiTimestampTypeDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDataCustomUiTimestampTypeDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "timestamp_type_default",
        argNames: [],
      );

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_String_Output_String_AnyhowException(
          FutureOr<String> Function(String) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_String(rawArg0);

      Box<String>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_String(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic, dynamic)
      encode_DartFn_Inputs_String_String_Output_unit_AnyhowException(
          FutureOr<void> Function(String, String) raw) {
    return (callId, rawArg0, rawArg1) async {
      final arg0 = dco_decode_String(rawArg0);
      final arg1 = dco_decode_String(rawArg1);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0, arg1));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(
    int,
  ) encode_DartFn_Inputs__Output_String_AnyhowException(
      FutureOr<String> Function() raw) {
    return (
      callId,
    ) async {
      Box<String>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw());
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_String(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_action_Output_unit_AnyhowException(
          FutureOr<void> Function(Action) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_action(rawArg0);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic, dynamic, dynamic)
      encode_DartFn_Inputs_entry_id_String_setting_value_Output_unit_AnyhowException(
          FutureOr<void> Function(EntryId, String, SettingValue) raw) {
    return (callId, rawArg0, rawArg1, rawArg2) async {
      final arg0 = dco_decode_entry_id(rawArg0);
      final arg1 = dco_decode_String(rawArg1);
      final arg2 = dco_decode_setting_value(rawArg2);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0, arg1, arg2));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_extension_data_Output_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient_AnyhowException(
          FutureOr<ExtensionClient> Function(ExtensionData) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_extension_data(rawArg0);

      Box<ExtensionClient>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
            rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic, dynamic)
      encode_DartFn_Inputs_permission_opt_String_Output_bool_AnyhowException(
          FutureOr<bool> Function(Permission, String?) raw) {
    return (callId, rawArg0, rawArg1) async {
      final arg0 = dco_decode_permission(rawArg0);
      final arg1 = dco_decode_opt_String(rawArg1);

      Box<bool>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0, arg1));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_bool(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_CancelToken => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_CancelToken => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExtensionClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExtensionClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ManagerClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ManagerClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProxyAdapter => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProxyAdapter => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProxyExtension => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProxyExtension => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  CancelToken
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CancelTokenImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtensionClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtensionClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ManagerClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ManagerClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyAdapter
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyAdapterImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyExtension
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyExtension
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  CancelToken
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CancelTokenImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ManagerClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ManagerClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyAdapter
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyAdapterImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyExtension
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FutureOr<String> Function(String)
      dco_decode_DartFn_Inputs_String_Output_String_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<void> Function(String, String)
      dco_decode_DartFn_Inputs_String_String_Output_unit_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<String> Function()
      dco_decode_DartFn_Inputs__Output_String_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<void> Function(Action)
      dco_decode_DartFn_Inputs_action_Output_unit_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<void> Function(EntryId, String, SettingValue)
      dco_decode_DartFn_Inputs_entry_id_String_setting_value_Output_unit_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<ExtensionClient> Function(ExtensionData)
      dco_decode_DartFn_Inputs_extension_data_Output_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<bool> Function(Permission, String?)
      dco_decode_DartFn_Inputs_permission_opt_String_Output_bool_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  Object dco_decode_DartOpaque(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return decodeDartOpaque(raw, generalizedFrbRustBinding);
  }

  @protected
  Map<String, String> dco_decode_Map_String_String_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_string(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, List<String>> dco_decode_Map_String_list_String_None(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_list_string(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, Setting> dco_decode_Map_String_setting_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_setting(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  CancelToken
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CancelTokenImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtensionClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtensionClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ManagerClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ManagerClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyAdapter
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyAdapterImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyExtension
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Set<ExtensionType> dco_decode_Set_extension_type_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Set.from(dco_decode_list_extension_type(raw));
  }

  @protected
  Set<MediaType> dco_decode_Set_media_type_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Set.from(dco_decode_list_media_type(raw));
  }

  @protected
  Set<SourceOpenType> dco_decode_Set_source_open_type_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Set.from(dco_decode_list_source_open_type(raw));
  }

  @protected
  Set<SourceType> dco_decode_Set_source_type_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Set.from(dco_decode_list_source_type(raw));
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Account dco_decode_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return Account(
      domain: dco_decode_String(arr[0]),
      userName: dco_decode_opt_String(arr[1]),
      cover: dco_decode_opt_String(arr[2]),
      auth: dco_decode_auth_data(arr[3]),
      creds: dco_decode_opt_box_autoadd_auth_creds(arr[4]),
    );
  }

  @protected
  Action dco_decode_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Action_OpenBrowser(
          url: dco_decode_String(raw[1]),
        );
      case 1:
        return Action_Popup(
          title: dco_decode_String(raw[1]),
          content: dco_decode_box_custom_ui(raw[2]),
          actions: dco_decode_list_popup_action(raw[3]),
        );
      case 2:
        return Action_Nav(
          title: dco_decode_String(raw[1]),
          content: dco_decode_box_custom_ui(raw[2]),
        );
      case 3:
        return Action_TriggerEvent(
          event: dco_decode_String(raw[1]),
          data: dco_decode_String(raw[2]),
        );
      case 4:
        return Action_NavEntry(
          entry: dco_decode_box_entry_detailed(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AuthCreds dco_decode_auth_creds(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AuthCreds_Cookies(
          cookies: dco_decode_Map_String_list_String_None(raw[1]),
        );
      case 1:
        return AuthCreds_ApiKey(
          key: dco_decode_String(raw[1]),
        );
      case 2:
        return AuthCreds_UserPass(
          username: dco_decode_String(raw[1]),
          password: dco_decode_String(raw[2]),
        );
      case 3:
        return AuthCreds_OAuth(
          accessToken: dco_decode_String(raw[1]),
          refreshToken: dco_decode_opt_String(raw[2]),
          expiresAt: dco_decode_opt_box_autoadd_u_32(raw[3]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AuthData dco_decode_auth_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return AuthData_Cookie(
          loginpage: dco_decode_String(raw[1]),
          logonpage: dco_decode_String(raw[2]),
        );
      case 1:
        return const AuthData_ApiKey();
      case 2:
        return const AuthData_UserPass();
      case 3:
        return AuthData_OAuth(
          authorizationUrl: dco_decode_String(raw[1]),
          tokenUrl: dco_decode_opt_String(raw[2]),
          clientId: dco_decode_String(raw[3]),
          clientSecret: dco_decode_String(raw[4]),
          scope: dco_decode_opt_String(raw[5]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Action dco_decode_box_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_action(raw);
  }

  @protected
  CancelToken
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
        raw);
  }

  @protected
  Account dco_decode_box_autoadd_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_account(raw);
  }

  @protected
  AuthCreds dco_decode_box_autoadd_auth_creds(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_auth_creds(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  CustomUI dco_decode_box_autoadd_custom_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_custom_ui(raw);
  }

  @protected
  Entry dco_decode_box_autoadd_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_entry(raw);
  }

  @protected
  EntryActivity dco_decode_box_autoadd_entry_activity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_entry_activity(raw);
  }

  @protected
  EntryDetailed dco_decode_box_autoadd_entry_detailed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_entry_detailed(raw);
  }

  @protected
  EntryId dco_decode_box_autoadd_entry_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_entry_id(raw);
  }

  @protected
  EpisodeId dco_decode_box_autoadd_episode_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_episode_id(raw);
  }

  @protected
  EventData dco_decode_box_autoadd_event_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_event_data(raw);
  }

  @protected
  EventResult dco_decode_box_autoadd_event_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_event_result(raw);
  }

  @protected
  ExtensionRepo dco_decode_box_autoadd_extension_repo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_extension_repo(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  Link dco_decode_box_autoadd_link(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_link(raw);
  }

  @protected
  Permission dco_decode_box_autoadd_permission(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_permission(raw);
  }

  @protected
  Setting dco_decode_box_autoadd_setting(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_setting(raw);
  }

  @protected
  SettingValue dco_decode_box_autoadd_setting_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_setting_value(raw);
  }

  @protected
  SettingsUI dco_decode_box_autoadd_settings_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_settings_ui(raw);
  }

  @protected
  Source dco_decode_box_autoadd_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_source(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  CustomUI dco_decode_box_custom_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_custom_ui(raw);
  }

  @protected
  EntryDetailed dco_decode_box_entry_detailed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_entry_detailed(raw);
  }

  @protected
  UIAction dco_decode_box_ui_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ui_action(raw);
  }

  @protected
  CustomUI dco_decode_custom_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return CustomUI_Text(
          text: dco_decode_String(raw[1]),
        );
      case 1:
        return CustomUI_Image(
          image: dco_decode_box_autoadd_link(raw[1]),
          width: dco_decode_opt_box_autoadd_i_32(raw[2]),
          height: dco_decode_opt_box_autoadd_i_32(raw[3]),
        );
      case 2:
        return CustomUI_Link(
          link: dco_decode_String(raw[1]),
          label: dco_decode_opt_String(raw[2]),
        );
      case 3:
        return CustomUI_TimeStamp(
          timestamp: dco_decode_String(raw[1]),
          display: dco_decode_timestamp_type(raw[2]),
        );
      case 4:
        return CustomUI_EntryCard(
          entry: dco_decode_box_autoadd_entry(raw[1]),
        );
      case 5:
        return CustomUI_Card(
          image: dco_decode_box_autoadd_link(raw[1]),
          top: dco_decode_box_custom_ui(raw[2]),
          bottom: dco_decode_box_custom_ui(raw[3]),
        );
      case 6:
        return CustomUI_Feed(
          event: dco_decode_String(raw[1]),
          data: dco_decode_String(raw[2]),
        );
      case 7:
        return CustomUI_Button(
          label: dco_decode_String(raw[1]),
          onClick: dco_decode_opt_box_ui_action(raw[2]),
        );
      case 8:
        return CustomUI_InlineSetting(
          settingId: dco_decode_String(raw[1]),
          settingKind: dco_decode_setting_kind(raw[2]),
          onCommit: dco_decode_opt_box_ui_action(raw[3]),
        );
      case 9:
        return CustomUI_Slot(
          id: dco_decode_String(raw[1]),
          child: dco_decode_box_custom_ui(raw[2]),
        );
      case 10:
        return CustomUI_Column(
          children: dco_decode_list_custom_ui(raw[1]),
        );
      case 11:
        return CustomUI_Row(
          children: dco_decode_list_custom_ui(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  DropdownOption dco_decode_dropdown_option(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return DropdownOption(
      label: dco_decode_String(arr[0]),
      value: dco_decode_String(arr[1]),
    );
  }

  @protected
  Entry dco_decode_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return Entry(
      id: dco_decode_entry_id(arr[0]),
      url: dco_decode_String(arr[1]),
      title: dco_decode_String(arr[2]),
      mediaType: dco_decode_media_type(arr[3]),
      cover: dco_decode_opt_box_autoadd_link(arr[4]),
      author: dco_decode_opt_list_String(arr[5]),
      rating: dco_decode_opt_box_autoadd_f_32(arr[6]),
      views: dco_decode_opt_box_autoadd_f_32(arr[7]),
      length: dco_decode_opt_box_autoadd_i_32(arr[8]),
    );
  }

  @protected
  EntryActivity dco_decode_entry_activity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return EntryActivity_EpisodeActivity(
          progress: dco_decode_i_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  EntryDetailed dco_decode_entry_detailed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 17)
      throw Exception('unexpected arr length: expect 17 but see ${arr.length}');
    return EntryDetailed(
      id: dco_decode_entry_id(arr[0]),
      url: dco_decode_String(arr[1]),
      titles: dco_decode_list_String(arr[2]),
      author: dco_decode_opt_list_String(arr[3]),
      ui: dco_decode_opt_box_autoadd_custom_ui(arr[4]),
      meta: dco_decode_opt_Map_String_String_None(arr[5]),
      mediaType: dco_decode_media_type(arr[6]),
      status: dco_decode_release_status(arr[7]),
      description: dco_decode_String(arr[8]),
      language: dco_decode_String(arr[9]),
      cover: dco_decode_opt_box_autoadd_link(arr[10]),
      poster: dco_decode_opt_box_autoadd_link(arr[11]),
      episodes: dco_decode_list_episode(arr[12]),
      genres: dco_decode_opt_list_String(arr[13]),
      rating: dco_decode_opt_box_autoadd_f_32(arr[14]),
      views: dco_decode_opt_box_autoadd_f_32(arr[15]),
      length: dco_decode_opt_box_autoadd_i_32(arr[16]),
    );
  }

  @protected
  EntryDetailedResult dco_decode_entry_detailed_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return EntryDetailedResult(
      entry: dco_decode_entry_detailed(arr[0]),
      settings: dco_decode_Map_String_setting_None(arr[1]),
    );
  }

  @protected
  EntryId dco_decode_entry_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return EntryId(
      uid: dco_decode_String(arr[0]),
      iddata: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  EntryList dco_decode_entry_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return EntryList(
      hasnext: dco_decode_opt_box_autoadd_bool(arr[0]),
      length: dco_decode_opt_box_autoadd_i_32(arr[1]),
      content: dco_decode_list_entry(arr[2]),
    );
  }

  @protected
  Episode dco_decode_episode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return Episode(
      id: dco_decode_episode_id(arr[0]),
      name: dco_decode_String(arr[1]),
      description: dco_decode_opt_String(arr[2]),
      url: dco_decode_String(arr[3]),
      cover: dco_decode_opt_box_autoadd_link(arr[4]),
      timestamp: dco_decode_opt_String(arr[5]),
    );
  }

  @protected
  EpisodeId dco_decode_episode_id(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return EpisodeId(
      uid: dco_decode_String(arr[0]),
      iddata: dco_decode_opt_String(arr[1]),
    );
  }

  @protected
  EventData dco_decode_event_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return EventData_SwapContent(
          event: dco_decode_String(raw[1]),
          targetid: dco_decode_String(raw[2]),
          data: dco_decode_String(raw[3]),
        );
      case 1:
        return EventData_FeedUpdate(
          event: dco_decode_String(raw[1]),
          data: dco_decode_String(raw[2]),
          page: dco_decode_i_32(raw[3]),
        );
      case 2:
        return EventData_Action(
          event: dco_decode_String(raw[1]),
          data: dco_decode_String(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  EventResult dco_decode_event_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return EventResult_SwapContent(
          customui: dco_decode_box_autoadd_custom_ui(raw[1]),
        );
      case 1:
        return EventResult_FeedUpdate(
          customui: dco_decode_list_custom_ui(raw[1]),
          hasnext: dco_decode_opt_box_autoadd_bool(raw[2]),
          length: dco_decode_opt_box_autoadd_i_32(raw[3]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  ExtensionData dco_decode_extension_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 15)
      throw Exception('unexpected arr length: expect 15 but see ${arr.length}');
    return ExtensionData(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      url: dco_decode_String(arr[2]),
      icon: dco_decode_String(arr[3]),
      desc: dco_decode_opt_String(arr[4]),
      author: dco_decode_list_String(arr[5]),
      tags: dco_decode_list_String(arr[6]),
      lang: dco_decode_list_String(arr[7]),
      nsfw: dco_decode_bool(arr[8]),
      mediaType: dco_decode_Set_media_type_None(arr[9]),
      extensionType: dco_decode_Set_extension_type_None(arr[10]),
      repo: dco_decode_opt_String(arr[11]),
      version: dco_decode_String(arr[12]),
      license: dco_decode_String(arr[13]),
      compatible: dco_decode_bool(arr[14]),
    );
  }

  @protected
  ExtensionManagerData dco_decode_extension_manager_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ExtensionManagerData(
      name: dco_decode_String(arr[0]),
      icon: dco_decode_opt_String(arr[1]),
      repo: dco_decode_opt_String(arr[2]),
      apiVersion: dco_decode_u_32(arr[3]),
    );
  }

  @protected
  ExtensionRepo dco_decode_extension_repo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ExtensionRepo(
      remoteId: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      description: dco_decode_String(arr[2]),
      url: dco_decode_String(arr[3]),
    );
  }

  @protected
  ExtensionType dco_decode_extension_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ExtensionType_EntryProvider(
          hasSearch: dco_decode_bool(raw[1]),
        );
      case 1:
        return ExtensionType_SourceProcessor(
          sourcetypes: dco_decode_Set_source_type_None(raw[1]),
          opentype: dco_decode_Set_source_open_type_None(raw[2]),
        );
      case 2:
        return ExtensionType_EntryProcessor(
          triggerMapEntry: dco_decode_bool(raw[1]),
          triggerOnEntryActivity: dco_decode_bool(raw[2]),
        );
      case 3:
        return ExtensionType_URLHandler(
          urlPatterns: dco_decode_list_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ImageListAudio dco_decode_image_list_audio(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ImageListAudio(
      link: dco_decode_link(arr[0]),
      from: dco_decode_i_32(arr[1]),
      to: dco_decode_i_32(arr[2]),
    );
  }

  @protected
  PlatformInt64 dco_decode_isize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  Link dco_decode_link(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Link(
      url: dco_decode_String(arr[0]),
      header: dco_decode_opt_Map_String_String_None(arr[1]),
    );
  }

  @protected
  List<ProxyExtension>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension)
        .toList();
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<Account> dco_decode_list_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_account).toList();
  }

  @protected
  List<CustomUI> dco_decode_list_custom_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_custom_ui).toList();
  }

  @protected
  List<DropdownOption> dco_decode_list_dropdown_option(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_dropdown_option).toList();
  }

  @protected
  List<Entry> dco_decode_list_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_entry).toList();
  }

  @protected
  List<Episode> dco_decode_list_episode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_episode).toList();
  }

  @protected
  List<ExtensionType> dco_decode_list_extension_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_extension_type).toList();
  }

  @protected
  List<ImageListAudio> dco_decode_list_image_list_audio(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_image_list_audio).toList();
  }

  @protected
  List<Link> dco_decode_list_link(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_link).toList();
  }

  @protected
  List<MediaType> dco_decode_list_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_media_type).toList();
  }

  @protected
  List<MixedContent> dco_decode_list_mixed_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_mixed_content).toList();
  }

  @protected
  List<Paragraph> dco_decode_list_paragraph(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_paragraph).toList();
  }

  @protected
  List<Permission> dco_decode_list_permission(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_permission).toList();
  }

  @protected
  List<PopupAction> dco_decode_list_popup_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_popup_action).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String, List<String>)> dco_decode_list_record_string_list_string(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_list_string)
        .toList();
  }

  @protected
  List<(String, Setting)> dco_decode_list_record_string_setting(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_setting)
        .toList();
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<RemoteExtension> dco_decode_list_remote_extension(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_remote_extension).toList();
  }

  @protected
  List<Row> dco_decode_list_row(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_row).toList();
  }

  @protected
  List<SourceOpenType> dco_decode_list_source_open_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_source_open_type).toList();
  }

  @protected
  List<SourceType> dco_decode_list_source_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_source_type).toList();
  }

  @protected
  List<StreamSource> dco_decode_list_stream_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_stream_source).toList();
  }

  @protected
  List<Subtitles> dco_decode_list_subtitles(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_subtitles).toList();
  }

  @protected
  MediaType dco_decode_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaType.values[raw as int];
  }

  @protected
  MixedContent dco_decode_mixed_content(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return MixedContent_Text(
          content: dco_decode_String(raw[1]),
        );
      case 1:
        return MixedContent_CustomUI(
          ui: dco_decode_box_custom_ui(raw[1]),
        );
      case 2:
        return MixedContent_Table(
          columns: dco_decode_list_row(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Map<String, String>? dco_decode_opt_Map_String_String_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_Map_String_String_None(raw);
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  CancelToken?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            raw);
  }

  @protected
  Account? dco_decode_opt_box_autoadd_account(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_account(raw);
  }

  @protected
  AuthCreds? dco_decode_opt_box_autoadd_auth_creds(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_auth_creds(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  CustomUI? dco_decode_opt_box_autoadd_custom_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_custom_ui(raw);
  }

  @protected
  EventResult? dco_decode_opt_box_autoadd_event_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_event_result(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  Link? dco_decode_opt_box_autoadd_link(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_link(raw);
  }

  @protected
  SettingsUI? dco_decode_opt_box_autoadd_settings_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_settings_ui(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  CustomUI? dco_decode_opt_box_custom_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_custom_ui(raw);
  }

  @protected
  UIAction? dco_decode_opt_box_ui_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_ui_action(raw);
  }

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_String(raw);
  }

  @protected
  List<ImageListAudio>? dco_decode_opt_list_image_list_audio(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_image_list_audio(raw);
  }

  @protected
  Paragraph dco_decode_paragraph(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Paragraph_Text(
          content: dco_decode_String(raw[1]),
        );
      case 1:
        return Paragraph_Mixed(
          content: dco_decode_list_mixed_content(raw[1]),
        );
      case 2:
        return Paragraph_CustomUI(
          ui: dco_decode_box_custom_ui(raw[1]),
        );
      case 3:
        return Paragraph_Table(
          columns: dco_decode_list_row(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Permission dco_decode_permission(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Permission_Storage(
          path: dco_decode_String(raw[1]),
          write: dco_decode_bool(raw[2]),
        );
      case 1:
        return Permission_Network(
          domains: dco_decode_list_String(raw[1]),
        );
      case 2:
        return const Permission_ActionPopup();
      case 3:
        return const Permission_ArbitraryNetwork();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PopupAction dco_decode_popup_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PopupAction(
      label: dco_decode_String(arr[0]),
      onclick: dco_decode_box_action(arr[1]),
    );
  }

  @protected
  (String, List<String>) dco_decode_record_string_list_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_list_String(arr[1]),
    );
  }

  @protected
  (String, Setting) dco_decode_record_string_setting(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_setting(arr[1]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  ReleaseStatus dco_decode_release_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ReleaseStatus.values[raw as int];
  }

  @protected
  RemoteExtension dco_decode_remote_extension(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return RemoteExtension(
      remoteId: dco_decode_String(arr[0]),
      id: dco_decode_String(arr[1]),
      name: dco_decode_String(arr[2]),
      url: dco_decode_String(arr[3]),
      cover: dco_decode_opt_box_autoadd_link(arr[4]),
      version: dco_decode_String(arr[5]),
      compatible: dco_decode_bool(arr[6]),
    );
  }

  @protected
  RemoteExtensionResult dco_decode_remote_extension_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RemoteExtensionResult(
      content: dco_decode_list_remote_extension(arr[0]),
      hasnext: dco_decode_opt_box_autoadd_bool(arr[1]),
      length: dco_decode_opt_box_autoadd_i_32(arr[2]),
    );
  }

  @protected
  Row dco_decode_row(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Row(
      cells: dco_decode_list_paragraph(arr[0]),
    );
  }

  @protected
  Setting dco_decode_setting(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return Setting(
      label: dco_decode_String(arr[0]),
      value: dco_decode_setting_value(arr[1]),
      default_: dco_decode_setting_value(arr[2]),
      visible: dco_decode_bool(arr[3]),
      ui: dco_decode_opt_box_autoadd_settings_ui(arr[4]),
    );
  }

  @protected
  SettingKind dco_decode_setting_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SettingKind.values[raw as int];
  }

  @protected
  SettingValue dco_decode_setting_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SettingValue_String(
          data: dco_decode_String(raw[1]),
        );
      case 1:
        return SettingValue_Number(
          data: dco_decode_f_32(raw[1]),
        );
      case 2:
        return SettingValue_Boolean(
          data: dco_decode_bool(raw[1]),
        );
      case 3:
        return SettingValue_StringList(
          data: dco_decode_list_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SettingsUI dco_decode_settings_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return const SettingsUI_CheckBox();
      case 1:
        return SettingsUI_Slider(
          min: dco_decode_f_64(raw[1]),
          max: dco_decode_f_64(raw[2]),
          step: dco_decode_i_32(raw[3]),
        );
      case 2:
        return SettingsUI_Dropdown(
          options: dco_decode_list_dropdown_option(raw[1]),
        );
      case 3:
        return SettingsUI_MultiDropdown(
          options: dco_decode_list_dropdown_option(raw[1]),
        );
      case 4:
        return SettingsUI_CustomUI(
          ui: dco_decode_box_autoadd_custom_ui(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Source dco_decode_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Source_Epub(
          link: dco_decode_box_autoadd_link(raw[1]),
        );
      case 1:
        return Source_Pdf(
          link: dco_decode_box_autoadd_link(raw[1]),
        );
      case 2:
        return Source_Imagelist(
          links: dco_decode_list_link(raw[1]),
          audio: dco_decode_opt_list_image_list_audio(raw[2]),
        );
      case 3:
        return Source_Video(
          sources: dco_decode_list_stream_source(raw[1]),
          sub: dco_decode_list_subtitles(raw[2]),
        );
      case 4:
        return Source_Audio(
          sources: dco_decode_list_stream_source(raw[1]),
        );
      case 5:
        return Source_Paragraphlist(
          paragraphs: dco_decode_list_paragraph(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SourceOpenType dco_decode_source_open_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SourceOpenType.values[raw as int];
  }

  @protected
  SourceResult dco_decode_source_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SourceResult(
      source: dco_decode_source(arr[0]),
      settings: dco_decode_Map_String_setting_None(arr[1]),
    );
  }

  @protected
  SourceType dco_decode_source_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SourceType.values[raw as int];
  }

  @protected
  StreamSource dco_decode_stream_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return StreamSource(
      name: dco_decode_String(arr[0]),
      lang: dco_decode_String(arr[1]),
      url: dco_decode_link(arr[2]),
    );
  }

  @protected
  Subtitles dco_decode_subtitles(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Subtitles(
      title: dco_decode_String(arr[0]),
      lang: dco_decode_String(arr[1]),
      url: dco_decode_link(arr[2]),
    );
  }

  @protected
  TimestampType dco_decode_timestamp_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TimestampType.values[raw as int];
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  UIAction dco_decode_ui_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return UIAction_Action(
          action: dco_decode_box_action(raw[1]),
        );
      case 1:
        return UIAction_SwapContent(
          targetid: dco_decode_String(raw[1]),
          event: dco_decode_String(raw[2]),
          data: dco_decode_String(raw[3]),
          placeholder: dco_decode_opt_box_custom_ui(raw[4]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  CancelToken
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CancelTokenImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExtensionClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtensionClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ManagerClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ManagerClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyAdapter
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyAdapterImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyExtension
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyExtension
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  CancelToken
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CancelTokenImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ManagerClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ManagerClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyAdapter
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyAdapterImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyExtension
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Object sse_decode_DartOpaque(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_isize(deserializer);
    return decodeDartOpaque(inner, generalizedFrbRustBinding);
  }

  @protected
  Map<String, String> sse_decode_Map_String_String_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_string(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, List<String>> sse_decode_Map_String_list_String_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_list_string(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, Setting> sse_decode_Map_String_setting_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_setting(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  CancelToken
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CancelTokenImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExtensionClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtensionClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ManagerClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ManagerClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyAdapter
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyAdapterImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyExtension
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Set<ExtensionType> sse_decode_Set_extension_type_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_extension_type(deserializer);
    return Set.from(inner);
  }

  @protected
  Set<MediaType> sse_decode_Set_media_type_None(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_media_type(deserializer);
    return Set.from(inner);
  }

  @protected
  Set<SourceOpenType> sse_decode_Set_source_open_type_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_source_open_type(deserializer);
    return Set.from(inner);
  }

  @protected
  Set<SourceType> sse_decode_Set_source_type_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_source_type(deserializer);
    return Set.from(inner);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Account sse_decode_account(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_domain = sse_decode_String(deserializer);
    var var_userName = sse_decode_opt_String(deserializer);
    var var_cover = sse_decode_opt_String(deserializer);
    var var_auth = sse_decode_auth_data(deserializer);
    var var_creds = sse_decode_opt_box_autoadd_auth_creds(deserializer);
    return Account(
        domain: var_domain,
        userName: var_userName,
        cover: var_cover,
        auth: var_auth,
        creds: var_creds);
  }

  @protected
  Action sse_decode_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_url = sse_decode_String(deserializer);
        return Action_OpenBrowser(url: var_url);
      case 1:
        var var_title = sse_decode_String(deserializer);
        var var_content = sse_decode_box_custom_ui(deserializer);
        var var_actions = sse_decode_list_popup_action(deserializer);
        return Action_Popup(
            title: var_title, content: var_content, actions: var_actions);
      case 2:
        var var_title = sse_decode_String(deserializer);
        var var_content = sse_decode_box_custom_ui(deserializer);
        return Action_Nav(title: var_title, content: var_content);
      case 3:
        var var_event = sse_decode_String(deserializer);
        var var_data = sse_decode_String(deserializer);
        return Action_TriggerEvent(event: var_event, data: var_data);
      case 4:
        var var_entry = sse_decode_box_entry_detailed(deserializer);
        return Action_NavEntry(entry: var_entry);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  AuthCreds sse_decode_auth_creds(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_cookies = sse_decode_Map_String_list_String_None(deserializer);
        return AuthCreds_Cookies(cookies: var_cookies);
      case 1:
        var var_key = sse_decode_String(deserializer);
        return AuthCreds_ApiKey(key: var_key);
      case 2:
        var var_username = sse_decode_String(deserializer);
        var var_password = sse_decode_String(deserializer);
        return AuthCreds_UserPass(
            username: var_username, password: var_password);
      case 3:
        var var_accessToken = sse_decode_String(deserializer);
        var var_refreshToken = sse_decode_opt_String(deserializer);
        var var_expiresAt = sse_decode_opt_box_autoadd_u_32(deserializer);
        return AuthCreds_OAuth(
            accessToken: var_accessToken,
            refreshToken: var_refreshToken,
            expiresAt: var_expiresAt);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  AuthData sse_decode_auth_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_loginpage = sse_decode_String(deserializer);
        var var_logonpage = sse_decode_String(deserializer);
        return AuthData_Cookie(
            loginpage: var_loginpage, logonpage: var_logonpage);
      case 1:
        return const AuthData_ApiKey();
      case 2:
        return const AuthData_UserPass();
      case 3:
        var var_authorizationUrl = sse_decode_String(deserializer);
        var var_tokenUrl = sse_decode_opt_String(deserializer);
        var var_clientId = sse_decode_String(deserializer);
        var var_clientSecret = sse_decode_String(deserializer);
        var var_scope = sse_decode_opt_String(deserializer);
        return AuthData_OAuth(
            authorizationUrl: var_authorizationUrl,
            tokenUrl: var_tokenUrl,
            clientId: var_clientId,
            clientSecret: var_clientSecret,
            scope: var_scope);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Action sse_decode_box_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_action(deserializer));
  }

  @protected
  CancelToken
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
        deserializer));
  }

  @protected
  Account sse_decode_box_autoadd_account(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_account(deserializer));
  }

  @protected
  AuthCreds sse_decode_box_autoadd_auth_creds(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_auth_creds(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  CustomUI sse_decode_box_autoadd_custom_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_custom_ui(deserializer));
  }

  @protected
  Entry sse_decode_box_autoadd_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_entry(deserializer));
  }

  @protected
  EntryActivity sse_decode_box_autoadd_entry_activity(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_entry_activity(deserializer));
  }

  @protected
  EntryDetailed sse_decode_box_autoadd_entry_detailed(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_entry_detailed(deserializer));
  }

  @protected
  EntryId sse_decode_box_autoadd_entry_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_entry_id(deserializer));
  }

  @protected
  EpisodeId sse_decode_box_autoadd_episode_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_episode_id(deserializer));
  }

  @protected
  EventData sse_decode_box_autoadd_event_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_event_data(deserializer));
  }

  @protected
  EventResult sse_decode_box_autoadd_event_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_event_result(deserializer));
  }

  @protected
  ExtensionRepo sse_decode_box_autoadd_extension_repo(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_extension_repo(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  Link sse_decode_box_autoadd_link(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_link(deserializer));
  }

  @protected
  Permission sse_decode_box_autoadd_permission(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_permission(deserializer));
  }

  @protected
  Setting sse_decode_box_autoadd_setting(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_setting(deserializer));
  }

  @protected
  SettingValue sse_decode_box_autoadd_setting_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_setting_value(deserializer));
  }

  @protected
  SettingsUI sse_decode_box_autoadd_settings_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_settings_ui(deserializer));
  }

  @protected
  Source sse_decode_box_autoadd_source(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_source(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  CustomUI sse_decode_box_custom_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_custom_ui(deserializer));
  }

  @protected
  EntryDetailed sse_decode_box_entry_detailed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_entry_detailed(deserializer));
  }

  @protected
  UIAction sse_decode_box_ui_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ui_action(deserializer));
  }

  @protected
  CustomUI sse_decode_custom_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_text = sse_decode_String(deserializer);
        return CustomUI_Text(text: var_text);
      case 1:
        var var_image = sse_decode_box_autoadd_link(deserializer);
        var var_width = sse_decode_opt_box_autoadd_i_32(deserializer);
        var var_height = sse_decode_opt_box_autoadd_i_32(deserializer);
        return CustomUI_Image(
            image: var_image, width: var_width, height: var_height);
      case 2:
        var var_link = sse_decode_String(deserializer);
        var var_label = sse_decode_opt_String(deserializer);
        return CustomUI_Link(link: var_link, label: var_label);
      case 3:
        var var_timestamp = sse_decode_String(deserializer);
        var var_display = sse_decode_timestamp_type(deserializer);
        return CustomUI_TimeStamp(
            timestamp: var_timestamp, display: var_display);
      case 4:
        var var_entry = sse_decode_box_autoadd_entry(deserializer);
        return CustomUI_EntryCard(entry: var_entry);
      case 5:
        var var_image = sse_decode_box_autoadd_link(deserializer);
        var var_top = sse_decode_box_custom_ui(deserializer);
        var var_bottom = sse_decode_box_custom_ui(deserializer);
        return CustomUI_Card(
            image: var_image, top: var_top, bottom: var_bottom);
      case 6:
        var var_event = sse_decode_String(deserializer);
        var var_data = sse_decode_String(deserializer);
        return CustomUI_Feed(event: var_event, data: var_data);
      case 7:
        var var_label = sse_decode_String(deserializer);
        var var_onClick = sse_decode_opt_box_ui_action(deserializer);
        return CustomUI_Button(label: var_label, onClick: var_onClick);
      case 8:
        var var_settingId = sse_decode_String(deserializer);
        var var_settingKind = sse_decode_setting_kind(deserializer);
        var var_onCommit = sse_decode_opt_box_ui_action(deserializer);
        return CustomUI_InlineSetting(
            settingId: var_settingId,
            settingKind: var_settingKind,
            onCommit: var_onCommit);
      case 9:
        var var_id = sse_decode_String(deserializer);
        var var_child = sse_decode_box_custom_ui(deserializer);
        return CustomUI_Slot(id: var_id, child: var_child);
      case 10:
        var var_children = sse_decode_list_custom_ui(deserializer);
        return CustomUI_Column(children: var_children);
      case 11:
        var var_children = sse_decode_list_custom_ui(deserializer);
        return CustomUI_Row(children: var_children);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  DropdownOption sse_decode_dropdown_option(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_label = sse_decode_String(deserializer);
    var var_value = sse_decode_String(deserializer);
    return DropdownOption(label: var_label, value: var_value);
  }

  @protected
  Entry sse_decode_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_entry_id(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_mediaType = sse_decode_media_type(deserializer);
    var var_cover = sse_decode_opt_box_autoadd_link(deserializer);
    var var_author = sse_decode_opt_list_String(deserializer);
    var var_rating = sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_views = sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_length = sse_decode_opt_box_autoadd_i_32(deserializer);
    return Entry(
        id: var_id,
        url: var_url,
        title: var_title,
        mediaType: var_mediaType,
        cover: var_cover,
        author: var_author,
        rating: var_rating,
        views: var_views,
        length: var_length);
  }

  @protected
  EntryActivity sse_decode_entry_activity(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_progress = sse_decode_i_32(deserializer);
        return EntryActivity_EpisodeActivity(progress: var_progress);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  EntryDetailed sse_decode_entry_detailed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_entry_id(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_titles = sse_decode_list_String(deserializer);
    var var_author = sse_decode_opt_list_String(deserializer);
    var var_ui = sse_decode_opt_box_autoadd_custom_ui(deserializer);
    var var_meta = sse_decode_opt_Map_String_String_None(deserializer);
    var var_mediaType = sse_decode_media_type(deserializer);
    var var_status = sse_decode_release_status(deserializer);
    var var_description = sse_decode_String(deserializer);
    var var_language = sse_decode_String(deserializer);
    var var_cover = sse_decode_opt_box_autoadd_link(deserializer);
    var var_poster = sse_decode_opt_box_autoadd_link(deserializer);
    var var_episodes = sse_decode_list_episode(deserializer);
    var var_genres = sse_decode_opt_list_String(deserializer);
    var var_rating = sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_views = sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_length = sse_decode_opt_box_autoadd_i_32(deserializer);
    return EntryDetailed(
        id: var_id,
        url: var_url,
        titles: var_titles,
        author: var_author,
        ui: var_ui,
        meta: var_meta,
        mediaType: var_mediaType,
        status: var_status,
        description: var_description,
        language: var_language,
        cover: var_cover,
        poster: var_poster,
        episodes: var_episodes,
        genres: var_genres,
        rating: var_rating,
        views: var_views,
        length: var_length);
  }

  @protected
  EntryDetailedResult sse_decode_entry_detailed_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_entry = sse_decode_entry_detailed(deserializer);
    var var_settings = sse_decode_Map_String_setting_None(deserializer);
    return EntryDetailedResult(entry: var_entry, settings: var_settings);
  }

  @protected
  EntryId sse_decode_entry_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uid = sse_decode_String(deserializer);
    var var_iddata = sse_decode_opt_String(deserializer);
    return EntryId(uid: var_uid, iddata: var_iddata);
  }

  @protected
  EntryList sse_decode_entry_list(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hasnext = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_length = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_content = sse_decode_list_entry(deserializer);
    return EntryList(
        hasnext: var_hasnext, length: var_length, content: var_content);
  }

  @protected
  Episode sse_decode_episode(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_episode_id(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_cover = sse_decode_opt_box_autoadd_link(deserializer);
    var var_timestamp = sse_decode_opt_String(deserializer);
    return Episode(
        id: var_id,
        name: var_name,
        description: var_description,
        url: var_url,
        cover: var_cover,
        timestamp: var_timestamp);
  }

  @protected
  EpisodeId sse_decode_episode_id(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uid = sse_decode_String(deserializer);
    var var_iddata = sse_decode_opt_String(deserializer);
    return EpisodeId(uid: var_uid, iddata: var_iddata);
  }

  @protected
  EventData sse_decode_event_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_event = sse_decode_String(deserializer);
        var var_targetid = sse_decode_String(deserializer);
        var var_data = sse_decode_String(deserializer);
        return EventData_SwapContent(
            event: var_event, targetid: var_targetid, data: var_data);
      case 1:
        var var_event = sse_decode_String(deserializer);
        var var_data = sse_decode_String(deserializer);
        var var_page = sse_decode_i_32(deserializer);
        return EventData_FeedUpdate(
            event: var_event, data: var_data, page: var_page);
      case 2:
        var var_event = sse_decode_String(deserializer);
        var var_data = sse_decode_String(deserializer);
        return EventData_Action(event: var_event, data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  EventResult sse_decode_event_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_customui = sse_decode_box_autoadd_custom_ui(deserializer);
        return EventResult_SwapContent(customui: var_customui);
      case 1:
        var var_customui = sse_decode_list_custom_ui(deserializer);
        var var_hasnext = sse_decode_opt_box_autoadd_bool(deserializer);
        var var_length = sse_decode_opt_box_autoadd_i_32(deserializer);
        return EventResult_FeedUpdate(
            customui: var_customui, hasnext: var_hasnext, length: var_length);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  ExtensionData sse_decode_extension_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_icon = sse_decode_String(deserializer);
    var var_desc = sse_decode_opt_String(deserializer);
    var var_author = sse_decode_list_String(deserializer);
    var var_tags = sse_decode_list_String(deserializer);
    var var_lang = sse_decode_list_String(deserializer);
    var var_nsfw = sse_decode_bool(deserializer);
    var var_mediaType = sse_decode_Set_media_type_None(deserializer);
    var var_extensionType = sse_decode_Set_extension_type_None(deserializer);
    var var_repo = sse_decode_opt_String(deserializer);
    var var_version = sse_decode_String(deserializer);
    var var_license = sse_decode_String(deserializer);
    var var_compatible = sse_decode_bool(deserializer);
    return ExtensionData(
        id: var_id,
        name: var_name,
        url: var_url,
        icon: var_icon,
        desc: var_desc,
        author: var_author,
        tags: var_tags,
        lang: var_lang,
        nsfw: var_nsfw,
        mediaType: var_mediaType,
        extensionType: var_extensionType,
        repo: var_repo,
        version: var_version,
        license: var_license,
        compatible: var_compatible);
  }

  @protected
  ExtensionManagerData sse_decode_extension_manager_data(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_icon = sse_decode_opt_String(deserializer);
    var var_repo = sse_decode_opt_String(deserializer);
    var var_apiVersion = sse_decode_u_32(deserializer);
    return ExtensionManagerData(
        name: var_name,
        icon: var_icon,
        repo: var_repo,
        apiVersion: var_apiVersion);
  }

  @protected
  ExtensionRepo sse_decode_extension_repo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_remoteId = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_description = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    return ExtensionRepo(
        remoteId: var_remoteId,
        name: var_name,
        description: var_description,
        url: var_url);
  }

  @protected
  ExtensionType sse_decode_extension_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_hasSearch = sse_decode_bool(deserializer);
        return ExtensionType_EntryProvider(hasSearch: var_hasSearch);
      case 1:
        var var_sourcetypes = sse_decode_Set_source_type_None(deserializer);
        var var_opentype = sse_decode_Set_source_open_type_None(deserializer);
        return ExtensionType_SourceProcessor(
            sourcetypes: var_sourcetypes, opentype: var_opentype);
      case 2:
        var var_triggerMapEntry = sse_decode_bool(deserializer);
        var var_triggerOnEntryActivity = sse_decode_bool(deserializer);
        return ExtensionType_EntryProcessor(
            triggerMapEntry: var_triggerMapEntry,
            triggerOnEntryActivity: var_triggerOnEntryActivity);
      case 3:
        var var_urlPatterns = sse_decode_list_String(deserializer);
        return ExtensionType_URLHandler(urlPatterns: var_urlPatterns);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  ImageListAudio sse_decode_image_list_audio(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_link = sse_decode_link(deserializer);
    var var_from = sse_decode_i_32(deserializer);
    var var_to = sse_decode_i_32(deserializer);
    return ImageListAudio(link: var_link, from: var_from, to: var_to);
  }

  @protected
  PlatformInt64 sse_decode_isize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  Link sse_decode_link(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_header = sse_decode_opt_Map_String_String_None(deserializer);
    return Link(url: var_url, header: var_header);
  }

  @protected
  List<ProxyExtension>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ProxyExtension>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<Account> sse_decode_list_account(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Account>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_account(deserializer));
    }
    return ans_;
  }

  @protected
  List<CustomUI> sse_decode_list_custom_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CustomUI>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_custom_ui(deserializer));
    }
    return ans_;
  }

  @protected
  List<DropdownOption> sse_decode_list_dropdown_option(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DropdownOption>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dropdown_option(deserializer));
    }
    return ans_;
  }

  @protected
  List<Entry> sse_decode_list_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Entry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<Episode> sse_decode_list_episode(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Episode>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_episode(deserializer));
    }
    return ans_;
  }

  @protected
  List<ExtensionType> sse_decode_list_extension_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ExtensionType>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_extension_type(deserializer));
    }
    return ans_;
  }

  @protected
  List<ImageListAudio> sse_decode_list_image_list_audio(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ImageListAudio>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_image_list_audio(deserializer));
    }
    return ans_;
  }

  @protected
  List<Link> sse_decode_list_link(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Link>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_link(deserializer));
    }
    return ans_;
  }

  @protected
  List<MediaType> sse_decode_list_media_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MediaType>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_media_type(deserializer));
    }
    return ans_;
  }

  @protected
  List<MixedContent> sse_decode_list_mixed_content(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MixedContent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_mixed_content(deserializer));
    }
    return ans_;
  }

  @protected
  List<Paragraph> sse_decode_list_paragraph(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Paragraph>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_paragraph(deserializer));
    }
    return ans_;
  }

  @protected
  List<Permission> sse_decode_list_permission(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Permission>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_permission(deserializer));
    }
    return ans_;
  }

  @protected
  List<PopupAction> sse_decode_list_popup_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PopupAction>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_popup_action(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, List<String>)> sse_decode_list_record_string_list_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, List<String>)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_list_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, Setting)> sse_decode_list_record_string_setting(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, Setting)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_setting(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<RemoteExtension> sse_decode_list_remote_extension(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RemoteExtension>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_remote_extension(deserializer));
    }
    return ans_;
  }

  @protected
  List<Row> sse_decode_list_row(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Row>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_row(deserializer));
    }
    return ans_;
  }

  @protected
  List<SourceOpenType> sse_decode_list_source_open_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SourceOpenType>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_source_open_type(deserializer));
    }
    return ans_;
  }

  @protected
  List<SourceType> sse_decode_list_source_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SourceType>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_source_type(deserializer));
    }
    return ans_;
  }

  @protected
  List<StreamSource> sse_decode_list_stream_source(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <StreamSource>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_stream_source(deserializer));
    }
    return ans_;
  }

  @protected
  List<Subtitles> sse_decode_list_subtitles(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Subtitles>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_subtitles(deserializer));
    }
    return ans_;
  }

  @protected
  MediaType sse_decode_media_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MediaType.values[inner];
  }

  @protected
  MixedContent sse_decode_mixed_content(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_content = sse_decode_String(deserializer);
        return MixedContent_Text(content: var_content);
      case 1:
        var var_ui = sse_decode_box_custom_ui(deserializer);
        return MixedContent_CustomUI(ui: var_ui);
      case 2:
        var var_columns = sse_decode_list_row(deserializer);
        return MixedContent_Table(columns: var_columns);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Map<String, String>? sse_decode_opt_Map_String_String_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_Map_String_String_None(deserializer));
    } else {
      return null;
    }
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  CancelToken?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  Account? sse_decode_opt_box_autoadd_account(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_account(deserializer));
    } else {
      return null;
    }
  }

  @protected
  AuthCreds? sse_decode_opt_box_autoadd_auth_creds(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_auth_creds(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  CustomUI? sse_decode_opt_box_autoadd_custom_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_custom_ui(deserializer));
    } else {
      return null;
    }
  }

  @protected
  EventResult? sse_decode_opt_box_autoadd_event_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_event_result(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Link? sse_decode_opt_box_autoadd_link(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_link(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SettingsUI? sse_decode_opt_box_autoadd_settings_ui(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_settings_ui(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  CustomUI? sse_decode_opt_box_custom_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_custom_ui(deserializer));
    } else {
      return null;
    }
  }

  @protected
  UIAction? sse_decode_opt_box_ui_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_ui_action(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<ImageListAudio>? sse_decode_opt_list_image_list_audio(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_image_list_audio(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Paragraph sse_decode_paragraph(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_content = sse_decode_String(deserializer);
        return Paragraph_Text(content: var_content);
      case 1:
        var var_content = sse_decode_list_mixed_content(deserializer);
        return Paragraph_Mixed(content: var_content);
      case 2:
        var var_ui = sse_decode_box_custom_ui(deserializer);
        return Paragraph_CustomUI(ui: var_ui);
      case 3:
        var var_columns = sse_decode_list_row(deserializer);
        return Paragraph_Table(columns: var_columns);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Permission sse_decode_permission(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_path = sse_decode_String(deserializer);
        var var_write = sse_decode_bool(deserializer);
        return Permission_Storage(path: var_path, write: var_write);
      case 1:
        var var_domains = sse_decode_list_String(deserializer);
        return Permission_Network(domains: var_domains);
      case 2:
        return const Permission_ActionPopup();
      case 3:
        return const Permission_ArbitraryNetwork();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PopupAction sse_decode_popup_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_label = sse_decode_String(deserializer);
    var var_onclick = sse_decode_box_action(deserializer);
    return PopupAction(label: var_label, onclick: var_onclick);
  }

  @protected
  (String, List<String>) sse_decode_record_string_list_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_list_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, Setting) sse_decode_record_string_setting(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_setting(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  ReleaseStatus sse_decode_release_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ReleaseStatus.values[inner];
  }

  @protected
  RemoteExtension sse_decode_remote_extension(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_remoteId = sse_decode_String(deserializer);
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_cover = sse_decode_opt_box_autoadd_link(deserializer);
    var var_version = sse_decode_String(deserializer);
    var var_compatible = sse_decode_bool(deserializer);
    return RemoteExtension(
        remoteId: var_remoteId,
        id: var_id,
        name: var_name,
        url: var_url,
        cover: var_cover,
        version: var_version,
        compatible: var_compatible);
  }

  @protected
  RemoteExtensionResult sse_decode_remote_extension_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_content = sse_decode_list_remote_extension(deserializer);
    var var_hasnext = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_length = sse_decode_opt_box_autoadd_i_32(deserializer);
    return RemoteExtensionResult(
        content: var_content, hasnext: var_hasnext, length: var_length);
  }

  @protected
  Row sse_decode_row(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_cells = sse_decode_list_paragraph(deserializer);
    return Row(cells: var_cells);
  }

  @protected
  Setting sse_decode_setting(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_label = sse_decode_String(deserializer);
    var var_value = sse_decode_setting_value(deserializer);
    var var_default_ = sse_decode_setting_value(deserializer);
    var var_visible = sse_decode_bool(deserializer);
    var var_ui = sse_decode_opt_box_autoadd_settings_ui(deserializer);
    return Setting(
        label: var_label,
        value: var_value,
        default_: var_default_,
        visible: var_visible,
        ui: var_ui);
  }

  @protected
  SettingKind sse_decode_setting_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SettingKind.values[inner];
  }

  @protected
  SettingValue sse_decode_setting_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_String(deserializer);
        return SettingValue_String(data: var_data);
      case 1:
        var var_data = sse_decode_f_32(deserializer);
        return SettingValue_Number(data: var_data);
      case 2:
        var var_data = sse_decode_bool(deserializer);
        return SettingValue_Boolean(data: var_data);
      case 3:
        var var_data = sse_decode_list_String(deserializer);
        return SettingValue_StringList(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SettingsUI sse_decode_settings_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return const SettingsUI_CheckBox();
      case 1:
        var var_min = sse_decode_f_64(deserializer);
        var var_max = sse_decode_f_64(deserializer);
        var var_step = sse_decode_i_32(deserializer);
        return SettingsUI_Slider(min: var_min, max: var_max, step: var_step);
      case 2:
        var var_options = sse_decode_list_dropdown_option(deserializer);
        return SettingsUI_Dropdown(options: var_options);
      case 3:
        var var_options = sse_decode_list_dropdown_option(deserializer);
        return SettingsUI_MultiDropdown(options: var_options);
      case 4:
        var var_ui = sse_decode_box_autoadd_custom_ui(deserializer);
        return SettingsUI_CustomUI(ui: var_ui);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Source sse_decode_source(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_link = sse_decode_box_autoadd_link(deserializer);
        return Source_Epub(link: var_link);
      case 1:
        var var_link = sse_decode_box_autoadd_link(deserializer);
        return Source_Pdf(link: var_link);
      case 2:
        var var_links = sse_decode_list_link(deserializer);
        var var_audio = sse_decode_opt_list_image_list_audio(deserializer);
        return Source_Imagelist(links: var_links, audio: var_audio);
      case 3:
        var var_sources = sse_decode_list_stream_source(deserializer);
        var var_sub = sse_decode_list_subtitles(deserializer);
        return Source_Video(sources: var_sources, sub: var_sub);
      case 4:
        var var_sources = sse_decode_list_stream_source(deserializer);
        return Source_Audio(sources: var_sources);
      case 5:
        var var_paragraphs = sse_decode_list_paragraph(deserializer);
        return Source_Paragraphlist(paragraphs: var_paragraphs);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SourceOpenType sse_decode_source_open_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SourceOpenType.values[inner];
  }

  @protected
  SourceResult sse_decode_source_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_source = sse_decode_source(deserializer);
    var var_settings = sse_decode_Map_String_setting_None(deserializer);
    return SourceResult(source: var_source, settings: var_settings);
  }

  @protected
  SourceType sse_decode_source_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SourceType.values[inner];
  }

  @protected
  StreamSource sse_decode_stream_source(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_lang = sse_decode_String(deserializer);
    var var_url = sse_decode_link(deserializer);
    return StreamSource(name: var_name, lang: var_lang, url: var_url);
  }

  @protected
  Subtitles sse_decode_subtitles(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_title = sse_decode_String(deserializer);
    var var_lang = sse_decode_String(deserializer);
    var var_url = sse_decode_link(deserializer);
    return Subtitles(title: var_title, lang: var_lang, url: var_url);
  }

  @protected
  TimestampType sse_decode_timestamp_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return TimestampType.values[inner];
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  UIAction sse_decode_ui_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_action = sse_decode_box_action(deserializer);
        return UIAction_Action(action: var_action);
      case 1:
        var var_targetid = sse_decode_String(deserializer);
        var var_event = sse_decode_String(deserializer);
        var var_data = sse_decode_String(deserializer);
        var var_placeholder = sse_decode_opt_box_custom_ui(deserializer);
        return UIAction_SwapContent(
            targetid: var_targetid,
            event: var_event,
            data: var_data,
            placeholder: var_placeholder);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
      CancelToken raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as CancelTokenImpl).frbInternalCstEncode(move: true);
  }

  @protected
  int cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
      ProxyAdapter raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyAdapterImpl).frbInternalCstEncode(move: true);
  }

  @protected
  int cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
      ProxyExtension raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyExtensionImpl).frbInternalCstEncode(move: true);
  }

  @protected
  int cst_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
      ProxyExtension raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyExtensionImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
      CancelToken raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as CancelTokenImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
      ManagerClient raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ManagerClientImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
      ProxyAdapter raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyAdapterImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
      ProxyExtension raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyExtensionImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
      CancelToken raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as CancelTokenImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
      ManagerClient raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ManagerClientImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
      ProxyAdapter raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyAdapterImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
      ProxyExtension raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyExtensionImpl).frbInternalCstEncode();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  double cst_encode_f_32(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  double cst_encode_f_64(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_media_type(MediaType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_release_status(ReleaseStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_setting_kind(SettingKind raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_source_open_type(SourceOpenType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_source_type(SourceType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_timestamp_type(TimestampType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          CancelToken self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CancelTokenImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
          ExtensionClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ExtensionClientImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          ManagerClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ManagerClientImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
          ProxyAdapter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyAdapterImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          ProxyExtension self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyExtensionImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          ProxyExtension self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyExtensionImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          CancelToken self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CancelTokenImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          ManagerClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ManagerClientImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
          ProxyAdapter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyAdapterImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          ProxyExtension self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyExtensionImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_String_Output_String_AnyhowException(
      FutureOr<String> Function(String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_String_Output_String_AnyhowException(self),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_String_String_Output_unit_AnyhowException(
      FutureOr<void> Function(String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_String_String_Output_unit_AnyhowException(self),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs__Output_String_AnyhowException(
      FutureOr<String> Function() self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs__Output_String_AnyhowException(self), serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_action_Output_unit_AnyhowException(
      FutureOr<void> Function(Action) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_action_Output_unit_AnyhowException(self),
        serializer);
  }

  @protected
  void
      sse_encode_DartFn_Inputs_entry_id_String_setting_value_Output_unit_AnyhowException(
          FutureOr<void> Function(EntryId, String, SettingValue) self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_entry_id_String_setting_value_Output_unit_AnyhowException(
            self),
        serializer);
  }

  @protected
  void
      sse_encode_DartFn_Inputs_extension_data_Output_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient_AnyhowException(
          FutureOr<ExtensionClient> Function(ExtensionData) self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_extension_data_Output_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient_AnyhowException(
            self),
        serializer);
  }

  @protected
  void
      sse_encode_DartFn_Inputs_permission_opt_String_Output_bool_AnyhowException(
          FutureOr<bool> Function(Permission, String?) self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_permission_opt_String_Output_bool_AnyhowException(
            self),
        serializer);
  }

  @protected
  void sse_encode_DartOpaque(Object self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_isize(
        PlatformPointerUtil.ptrToPlatformInt64(encodeDartOpaque(
            self, portManager.dartHandlerPort, generalizedFrbRustBinding)),
        serializer);
  }

  @protected
  void sse_encode_Map_String_String_None(
      Map<String, String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_string(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_Map_String_list_String_None(
      Map<String, List<String>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_list_string(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_Map_String_setting_None(
      Map<String, Setting> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_setting(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          CancelToken self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CancelTokenImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
          ExtensionClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ExtensionClientImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          ManagerClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ManagerClientImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyAdapter(
          ProxyAdapter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyAdapterImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          ProxyExtension self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyExtensionImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_Set_extension_type_None(
      Set<ExtensionType> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_extension_type(self.toList(), serializer);
  }

  @protected
  void sse_encode_Set_media_type_None(
      Set<MediaType> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_media_type(self.toList(), serializer);
  }

  @protected
  void sse_encode_Set_source_open_type_None(
      Set<SourceOpenType> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_source_open_type(self.toList(), serializer);
  }

  @protected
  void sse_encode_Set_source_type_None(
      Set<SourceType> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_source_type(self.toList(), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_account(Account self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.domain, serializer);
    sse_encode_opt_String(self.userName, serializer);
    sse_encode_opt_String(self.cover, serializer);
    sse_encode_auth_data(self.auth, serializer);
    sse_encode_opt_box_autoadd_auth_creds(self.creds, serializer);
  }

  @protected
  void sse_encode_action(Action self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Action_OpenBrowser(url: final url):
        sse_encode_i_32(0, serializer);
        sse_encode_String(url, serializer);
      case Action_Popup(
          title: final title,
          content: final content,
          actions: final actions
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_String(title, serializer);
        sse_encode_box_custom_ui(content, serializer);
        sse_encode_list_popup_action(actions, serializer);
      case Action_Nav(title: final title, content: final content):
        sse_encode_i_32(2, serializer);
        sse_encode_String(title, serializer);
        sse_encode_box_custom_ui(content, serializer);
      case Action_TriggerEvent(event: final event, data: final data):
        sse_encode_i_32(3, serializer);
        sse_encode_String(event, serializer);
        sse_encode_String(data, serializer);
      case Action_NavEntry(entry: final entry):
        sse_encode_i_32(4, serializer);
        sse_encode_box_entry_detailed(entry, serializer);
    }
  }

  @protected
  void sse_encode_auth_creds(AuthCreds self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AuthCreds_Cookies(cookies: final cookies):
        sse_encode_i_32(0, serializer);
        sse_encode_Map_String_list_String_None(cookies, serializer);
      case AuthCreds_ApiKey(key: final key):
        sse_encode_i_32(1, serializer);
        sse_encode_String(key, serializer);
      case AuthCreds_UserPass(
          username: final username,
          password: final password
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_String(username, serializer);
        sse_encode_String(password, serializer);
      case AuthCreds_OAuth(
          accessToken: final accessToken,
          refreshToken: final refreshToken,
          expiresAt: final expiresAt
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_String(accessToken, serializer);
        sse_encode_opt_String(refreshToken, serializer);
        sse_encode_opt_box_autoadd_u_32(expiresAt, serializer);
    }
  }

  @protected
  void sse_encode_auth_data(AuthData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case AuthData_Cookie(
          loginpage: final loginpage,
          logonpage: final logonpage
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_String(loginpage, serializer);
        sse_encode_String(logonpage, serializer);
      case AuthData_ApiKey():
        sse_encode_i_32(1, serializer);
      case AuthData_UserPass():
        sse_encode_i_32(2, serializer);
      case AuthData_OAuth(
          authorizationUrl: final authorizationUrl,
          tokenUrl: final tokenUrl,
          clientId: final clientId,
          clientSecret: final clientSecret,
          scope: final scope
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_String(authorizationUrl, serializer);
        sse_encode_opt_String(tokenUrl, serializer);
        sse_encode_String(clientId, serializer);
        sse_encode_String(clientSecret, serializer);
        sse_encode_opt_String(scope, serializer);
    }
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_action(Action self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_action(self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          CancelToken self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
        self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_account(Account self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_account(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_auth_creds(
      AuthCreds self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_auth_creds(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_custom_ui(
      CustomUI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_custom_ui(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_entry(Entry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entry(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_entry_activity(
      EntryActivity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entry_activity(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_entry_detailed(
      EntryDetailed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entry_detailed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_entry_id(EntryId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entry_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_episode_id(
      EpisodeId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_episode_id(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_event_data(
      EventData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_event_data(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_event_result(
      EventResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_event_result(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_extension_repo(
      ExtensionRepo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_extension_repo(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_link(Link self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_link(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_permission(
      Permission self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_permission(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_setting(Setting self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_setting(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_setting_value(
      SettingValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_setting_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_settings_ui(
      SettingsUI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_settings_ui(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_source(Source self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_source(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_custom_ui(CustomUI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_custom_ui(self, serializer);
  }

  @protected
  void sse_encode_box_entry_detailed(
      EntryDetailed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entry_detailed(self, serializer);
  }

  @protected
  void sse_encode_box_ui_action(UIAction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ui_action(self, serializer);
  }

  @protected
  void sse_encode_custom_ui(CustomUI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case CustomUI_Text(text: final text):
        sse_encode_i_32(0, serializer);
        sse_encode_String(text, serializer);
      case CustomUI_Image(
          image: final image,
          width: final width,
          height: final height
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_link(image, serializer);
        sse_encode_opt_box_autoadd_i_32(width, serializer);
        sse_encode_opt_box_autoadd_i_32(height, serializer);
      case CustomUI_Link(link: final link, label: final label):
        sse_encode_i_32(2, serializer);
        sse_encode_String(link, serializer);
        sse_encode_opt_String(label, serializer);
      case CustomUI_TimeStamp(
          timestamp: final timestamp,
          display: final display
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_String(timestamp, serializer);
        sse_encode_timestamp_type(display, serializer);
      case CustomUI_EntryCard(entry: final entry):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_entry(entry, serializer);
      case CustomUI_Card(
          image: final image,
          top: final top,
          bottom: final bottom
        ):
        sse_encode_i_32(5, serializer);
        sse_encode_box_autoadd_link(image, serializer);
        sse_encode_box_custom_ui(top, serializer);
        sse_encode_box_custom_ui(bottom, serializer);
      case CustomUI_Feed(event: final event, data: final data):
        sse_encode_i_32(6, serializer);
        sse_encode_String(event, serializer);
        sse_encode_String(data, serializer);
      case CustomUI_Button(label: final label, onClick: final onClick):
        sse_encode_i_32(7, serializer);
        sse_encode_String(label, serializer);
        sse_encode_opt_box_ui_action(onClick, serializer);
      case CustomUI_InlineSetting(
          settingId: final settingId,
          settingKind: final settingKind,
          onCommit: final onCommit
        ):
        sse_encode_i_32(8, serializer);
        sse_encode_String(settingId, serializer);
        sse_encode_setting_kind(settingKind, serializer);
        sse_encode_opt_box_ui_action(onCommit, serializer);
      case CustomUI_Slot(id: final id, child: final child):
        sse_encode_i_32(9, serializer);
        sse_encode_String(id, serializer);
        sse_encode_box_custom_ui(child, serializer);
      case CustomUI_Column(children: final children):
        sse_encode_i_32(10, serializer);
        sse_encode_list_custom_ui(children, serializer);
      case CustomUI_Row(children: final children):
        sse_encode_i_32(11, serializer);
        sse_encode_list_custom_ui(children, serializer);
    }
  }

  @protected
  void sse_encode_dropdown_option(
      DropdownOption self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.label, serializer);
    sse_encode_String(self.value, serializer);
  }

  @protected
  void sse_encode_entry(Entry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entry_id(self.id, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_media_type(self.mediaType, serializer);
    sse_encode_opt_box_autoadd_link(self.cover, serializer);
    sse_encode_opt_list_String(self.author, serializer);
    sse_encode_opt_box_autoadd_f_32(self.rating, serializer);
    sse_encode_opt_box_autoadd_f_32(self.views, serializer);
    sse_encode_opt_box_autoadd_i_32(self.length, serializer);
  }

  @protected
  void sse_encode_entry_activity(EntryActivity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case EntryActivity_EpisodeActivity(progress: final progress):
        sse_encode_i_32(0, serializer);
        sse_encode_i_32(progress, serializer);
    }
  }

  @protected
  void sse_encode_entry_detailed(EntryDetailed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entry_id(self.id, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_list_String(self.titles, serializer);
    sse_encode_opt_list_String(self.author, serializer);
    sse_encode_opt_box_autoadd_custom_ui(self.ui, serializer);
    sse_encode_opt_Map_String_String_None(self.meta, serializer);
    sse_encode_media_type(self.mediaType, serializer);
    sse_encode_release_status(self.status, serializer);
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.language, serializer);
    sse_encode_opt_box_autoadd_link(self.cover, serializer);
    sse_encode_opt_box_autoadd_link(self.poster, serializer);
    sse_encode_list_episode(self.episodes, serializer);
    sse_encode_opt_list_String(self.genres, serializer);
    sse_encode_opt_box_autoadd_f_32(self.rating, serializer);
    sse_encode_opt_box_autoadd_f_32(self.views, serializer);
    sse_encode_opt_box_autoadd_i_32(self.length, serializer);
  }

  @protected
  void sse_encode_entry_detailed_result(
      EntryDetailedResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entry_detailed(self.entry, serializer);
    sse_encode_Map_String_setting_None(self.settings, serializer);
  }

  @protected
  void sse_encode_entry_id(EntryId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.uid, serializer);
    sse_encode_opt_String(self.iddata, serializer);
  }

  @protected
  void sse_encode_entry_list(EntryList self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_bool(self.hasnext, serializer);
    sse_encode_opt_box_autoadd_i_32(self.length, serializer);
    sse_encode_list_entry(self.content, serializer);
  }

  @protected
  void sse_encode_episode(Episode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_episode_id(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_opt_box_autoadd_link(self.cover, serializer);
    sse_encode_opt_String(self.timestamp, serializer);
  }

  @protected
  void sse_encode_episode_id(EpisodeId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.uid, serializer);
    sse_encode_opt_String(self.iddata, serializer);
  }

  @protected
  void sse_encode_event_data(EventData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case EventData_SwapContent(
          event: final event,
          targetid: final targetid,
          data: final data
        ):
        sse_encode_i_32(0, serializer);
        sse_encode_String(event, serializer);
        sse_encode_String(targetid, serializer);
        sse_encode_String(data, serializer);
      case EventData_FeedUpdate(
          event: final event,
          data: final data,
          page: final page
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_String(event, serializer);
        sse_encode_String(data, serializer);
        sse_encode_i_32(page, serializer);
      case EventData_Action(event: final event, data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_String(event, serializer);
        sse_encode_String(data, serializer);
    }
  }

  @protected
  void sse_encode_event_result(EventResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case EventResult_SwapContent(customui: final customui):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_custom_ui(customui, serializer);
      case EventResult_FeedUpdate(
          customui: final customui,
          hasnext: final hasnext,
          length: final length
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_list_custom_ui(customui, serializer);
        sse_encode_opt_box_autoadd_bool(hasnext, serializer);
        sse_encode_opt_box_autoadd_i_32(length, serializer);
    }
  }

  @protected
  void sse_encode_extension_data(ExtensionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.icon, serializer);
    sse_encode_opt_String(self.desc, serializer);
    sse_encode_list_String(self.author, serializer);
    sse_encode_list_String(self.tags, serializer);
    sse_encode_list_String(self.lang, serializer);
    sse_encode_bool(self.nsfw, serializer);
    sse_encode_Set_media_type_None(self.mediaType, serializer);
    sse_encode_Set_extension_type_None(self.extensionType, serializer);
    sse_encode_opt_String(self.repo, serializer);
    sse_encode_String(self.version, serializer);
    sse_encode_String(self.license, serializer);
    sse_encode_bool(self.compatible, serializer);
  }

  @protected
  void sse_encode_extension_manager_data(
      ExtensionManagerData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_opt_String(self.icon, serializer);
    sse_encode_opt_String(self.repo, serializer);
    sse_encode_u_32(self.apiVersion, serializer);
  }

  @protected
  void sse_encode_extension_repo(ExtensionRepo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.remoteId, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.url, serializer);
  }

  @protected
  void sse_encode_extension_type(ExtensionType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ExtensionType_EntryProvider(hasSearch: final hasSearch):
        sse_encode_i_32(0, serializer);
        sse_encode_bool(hasSearch, serializer);
      case ExtensionType_SourceProcessor(
          sourcetypes: final sourcetypes,
          opentype: final opentype
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_Set_source_type_None(sourcetypes, serializer);
        sse_encode_Set_source_open_type_None(opentype, serializer);
      case ExtensionType_EntryProcessor(
          triggerMapEntry: final triggerMapEntry,
          triggerOnEntryActivity: final triggerOnEntryActivity
        ):
        sse_encode_i_32(2, serializer);
        sse_encode_bool(triggerMapEntry, serializer);
        sse_encode_bool(triggerOnEntryActivity, serializer);
      case ExtensionType_URLHandler(urlPatterns: final urlPatterns):
        sse_encode_i_32(3, serializer);
        sse_encode_list_String(urlPatterns, serializer);
    }
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_image_list_audio(
      ImageListAudio self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_link(self.link, serializer);
    sse_encode_i_32(self.from, serializer);
    sse_encode_i_32(self.to, serializer);
  }

  @protected
  void sse_encode_isize(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_link(Link self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_opt_Map_String_String_None(self.header, serializer);
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          List<ProxyExtension> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          item, serializer);
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_account(List<Account> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_account(item, serializer);
    }
  }

  @protected
  void sse_encode_list_custom_ui(
      List<CustomUI> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_custom_ui(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dropdown_option(
      List<DropdownOption> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dropdown_option(item, serializer);
    }
  }

  @protected
  void sse_encode_list_entry(List<Entry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_episode(List<Episode> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_episode(item, serializer);
    }
  }

  @protected
  void sse_encode_list_extension_type(
      List<ExtensionType> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_extension_type(item, serializer);
    }
  }

  @protected
  void sse_encode_list_image_list_audio(
      List<ImageListAudio> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_image_list_audio(item, serializer);
    }
  }

  @protected
  void sse_encode_list_link(List<Link> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_link(item, serializer);
    }
  }

  @protected
  void sse_encode_list_media_type(
      List<MediaType> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_media_type(item, serializer);
    }
  }

  @protected
  void sse_encode_list_mixed_content(
      List<MixedContent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_mixed_content(item, serializer);
    }
  }

  @protected
  void sse_encode_list_paragraph(
      List<Paragraph> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_paragraph(item, serializer);
    }
  }

  @protected
  void sse_encode_list_permission(
      List<Permission> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_permission(item, serializer);
    }
  }

  @protected
  void sse_encode_list_popup_action(
      List<PopupAction> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_popup_action(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_string_list_string(
      List<(String, List<String>)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_list_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_setting(
      List<(String, Setting)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_setting(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_string(
      List<(String, String)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_remote_extension(
      List<RemoteExtension> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_remote_extension(item, serializer);
    }
  }

  @protected
  void sse_encode_list_row(List<Row> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_row(item, serializer);
    }
  }

  @protected
  void sse_encode_list_source_open_type(
      List<SourceOpenType> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_source_open_type(item, serializer);
    }
  }

  @protected
  void sse_encode_list_source_type(
      List<SourceType> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_source_type(item, serializer);
    }
  }

  @protected
  void sse_encode_list_stream_source(
      List<StreamSource> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_stream_source(item, serializer);
    }
  }

  @protected
  void sse_encode_list_subtitles(
      List<Subtitles> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_subtitles(item, serializer);
    }
  }

  @protected
  void sse_encode_media_type(MediaType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_mixed_content(MixedContent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case MixedContent_Text(content: final content):
        sse_encode_i_32(0, serializer);
        sse_encode_String(content, serializer);
      case MixedContent_CustomUI(ui: final ui):
        sse_encode_i_32(1, serializer);
        sse_encode_box_custom_ui(ui, serializer);
      case MixedContent_Table(columns: final columns):
        sse_encode_i_32(2, serializer);
        sse_encode_list_row(columns, serializer);
    }
  }

  @protected
  void sse_encode_opt_Map_String_String_None(
      Map<String, String>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_Map_String_String_None(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          CancelToken? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_account(
      Account? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_account(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_auth_creds(
      AuthCreds? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_auth_creds(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_custom_ui(
      CustomUI? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_custom_ui(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_event_result(
      EventResult? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_event_result(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_link(Link? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_link(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_settings_ui(
      SettingsUI? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_settings_ui(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_custom_ui(CustomUI? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_custom_ui(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_ui_action(UIAction? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_ui_action(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_String(
      List<String>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_image_list_audio(
      List<ImageListAudio>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_image_list_audio(self, serializer);
    }
  }

  @protected
  void sse_encode_paragraph(Paragraph self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Paragraph_Text(content: final content):
        sse_encode_i_32(0, serializer);
        sse_encode_String(content, serializer);
      case Paragraph_Mixed(content: final content):
        sse_encode_i_32(1, serializer);
        sse_encode_list_mixed_content(content, serializer);
      case Paragraph_CustomUI(ui: final ui):
        sse_encode_i_32(2, serializer);
        sse_encode_box_custom_ui(ui, serializer);
      case Paragraph_Table(columns: final columns):
        sse_encode_i_32(3, serializer);
        sse_encode_list_row(columns, serializer);
    }
  }

  @protected
  void sse_encode_permission(Permission self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Permission_Storage(path: final path, write: final write):
        sse_encode_i_32(0, serializer);
        sse_encode_String(path, serializer);
        sse_encode_bool(write, serializer);
      case Permission_Network(domains: final domains):
        sse_encode_i_32(1, serializer);
        sse_encode_list_String(domains, serializer);
      case Permission_ActionPopup():
        sse_encode_i_32(2, serializer);
      case Permission_ArbitraryNetwork():
        sse_encode_i_32(3, serializer);
    }
  }

  @protected
  void sse_encode_popup_action(PopupAction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.label, serializer);
    sse_encode_box_action(self.onclick, serializer);
  }

  @protected
  void sse_encode_record_string_list_string(
      (String, List<String>) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_list_String(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_setting(
      (String, Setting) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_setting(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_release_status(ReleaseStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_remote_extension(
      RemoteExtension self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.remoteId, serializer);
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_opt_box_autoadd_link(self.cover, serializer);
    sse_encode_String(self.version, serializer);
    sse_encode_bool(self.compatible, serializer);
  }

  @protected
  void sse_encode_remote_extension_result(
      RemoteExtensionResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_remote_extension(self.content, serializer);
    sse_encode_opt_box_autoadd_bool(self.hasnext, serializer);
    sse_encode_opt_box_autoadd_i_32(self.length, serializer);
  }

  @protected
  void sse_encode_row(Row self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_paragraph(self.cells, serializer);
  }

  @protected
  void sse_encode_setting(Setting self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.label, serializer);
    sse_encode_setting_value(self.value, serializer);
    sse_encode_setting_value(self.default_, serializer);
    sse_encode_bool(self.visible, serializer);
    sse_encode_opt_box_autoadd_settings_ui(self.ui, serializer);
  }

  @protected
  void sse_encode_setting_kind(SettingKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_setting_value(SettingValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SettingValue_String(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_String(data, serializer);
      case SettingValue_Number(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_f_32(data, serializer);
      case SettingValue_Boolean(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_bool(data, serializer);
      case SettingValue_StringList(data: final data):
        sse_encode_i_32(3, serializer);
        sse_encode_list_String(data, serializer);
    }
  }

  @protected
  void sse_encode_settings_ui(SettingsUI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SettingsUI_CheckBox():
        sse_encode_i_32(0, serializer);
      case SettingsUI_Slider(min: final min, max: final max, step: final step):
        sse_encode_i_32(1, serializer);
        sse_encode_f_64(min, serializer);
        sse_encode_f_64(max, serializer);
        sse_encode_i_32(step, serializer);
      case SettingsUI_Dropdown(options: final options):
        sse_encode_i_32(2, serializer);
        sse_encode_list_dropdown_option(options, serializer);
      case SettingsUI_MultiDropdown(options: final options):
        sse_encode_i_32(3, serializer);
        sse_encode_list_dropdown_option(options, serializer);
      case SettingsUI_CustomUI(ui: final ui):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_custom_ui(ui, serializer);
    }
  }

  @protected
  void sse_encode_source(Source self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Source_Epub(link: final link):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_link(link, serializer);
      case Source_Pdf(link: final link):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_link(link, serializer);
      case Source_Imagelist(links: final links, audio: final audio):
        sse_encode_i_32(2, serializer);
        sse_encode_list_link(links, serializer);
        sse_encode_opt_list_image_list_audio(audio, serializer);
      case Source_Video(sources: final sources, sub: final sub):
        sse_encode_i_32(3, serializer);
        sse_encode_list_stream_source(sources, serializer);
        sse_encode_list_subtitles(sub, serializer);
      case Source_Audio(sources: final sources):
        sse_encode_i_32(4, serializer);
        sse_encode_list_stream_source(sources, serializer);
      case Source_Paragraphlist(paragraphs: final paragraphs):
        sse_encode_i_32(5, serializer);
        sse_encode_list_paragraph(paragraphs, serializer);
    }
  }

  @protected
  void sse_encode_source_open_type(
      SourceOpenType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_source_result(SourceResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_source(self.source, serializer);
    sse_encode_Map_String_setting_None(self.settings, serializer);
  }

  @protected
  void sse_encode_source_type(SourceType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_stream_source(StreamSource self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.lang, serializer);
    sse_encode_link(self.url, serializer);
  }

  @protected
  void sse_encode_subtitles(Subtitles self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.lang, serializer);
    sse_encode_link(self.url, serializer);
  }

  @protected
  void sse_encode_timestamp_type(TimestampType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_ui_action(UIAction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case UIAction_Action(action: final action):
        sse_encode_i_32(0, serializer);
        sse_encode_box_action(action, serializer);
      case UIAction_SwapContent(
          targetid: final targetid,
          event: final event,
          data: final data,
          placeholder: final placeholder
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_String(targetid, serializer);
        sse_encode_String(event, serializer);
        sse_encode_String(data, serializer);
        sse_encode_opt_box_custom_ui(placeholder, serializer);
    }
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}

@sealed
class CancelTokenImpl extends RustOpaque implements CancelToken {
  // Not to be used by end users
  CancelTokenImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  CancelTokenImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_CancelToken,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_CancelToken,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_CancelTokenPtr,
  );

  Future<void> cancel() => RustLib.instance.api.crateApiCancelCancelTokenCancel(
        that: this,
      );

  Future<CancelToken> getChild() =>
      RustLib.instance.api.crateApiCancelCancelTokenGetChild(
        that: this,
      );

  Future<bool> isCancelled() =>
      RustLib.instance.api.crateApiCancelCancelTokenIsCancelled(
        that: this,
      );
}

@sealed
class ExtensionClientImpl extends RustOpaque implements ExtensionClient {
  // Not to be used by end users
  ExtensionClientImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ExtensionClientImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ExtensionClient,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ExtensionClient,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ExtensionClientPtr,
  );
}

@sealed
class ManagerClientImpl extends RustOpaque implements ManagerClient {
  // Not to be used by end users
  ManagerClientImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ManagerClientImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ManagerClient,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ManagerClient,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ManagerClientPtr,
  );
}

@sealed
class ProxyAdapterImpl extends RustOpaque implements ProxyAdapter {
  // Not to be used by end users
  ProxyAdapterImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ProxyAdapterImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ProxyAdapter,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ProxyAdapter,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ProxyAdapterPtr,
  );

  Future<RemoteExtensionResult> browseRepo(
          {required ExtensionRepo repo, required int page}) =>
      RustLib.instance.api.crateApiExtensionProxyAdapterBrowseRepo(
          that: this, repo: repo, page: page);

  Future<List<ProxyExtension>> getExtensions() =>
      RustLib.instance.api.crateApiExtensionProxyAdapterGetExtensions(
        that: this,
      );

  Future<ExtensionRepo> getRepo({required String url}) => RustLib.instance.api
      .crateApiExtensionProxyAdapterGetRepo(that: this, url: url);

  Future<ProxyExtension> install({required String location}) =>
      RustLib.instance.api
          .crateApiExtensionProxyAdapterInstall(that: this, location: location);

  Future<void> uninstall({required ProxyExtension ext}) => RustLib.instance.api
      .crateApiExtensionProxyAdapterUninstall(that: this, ext: ext);
}

@sealed
class ProxyExtensionImpl extends RustOpaque implements ProxyExtension {
  // Not to be used by end users
  ProxyExtensionImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ProxyExtensionImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ProxyExtension,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ProxyExtension,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ProxyExtensionPtr,
  );

  Future<EntryList> browse({required int page, CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionBrowse(
          that: this, page: page, token: token);

  Future<EntryDetailedResult> detail(
          {required EntryId entryid,
          required Map<String, Setting> settings,
          CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionDetail(
          that: this, entryid: entryid, settings: settings, token: token);

  Future<EventResult?> event({required EventData event, CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionEvent(
          that: this, event: event, token: token);

  Future<List<Account>> getAccounts() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionGetAccounts(
        that: this,
      );

  Future<ExtensionData> getExtensionData() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionGetExtensionData(
        that: this,
      );

  Future<List<Permission>> getPermissions() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionGetPermissions(
        that: this,
      );

  Future<Setting> getSetting({required String id, required SettingKind kind}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionGetSetting(
          that: this, id: id, kind: kind);

  Future<List<String>> getSettingIds({required SettingKind kind}) =>
      RustLib.instance.api
          .crateApiExtensionProxyExtensionGetSettingIds(that: this, kind: kind);

  Future<Map<String, Setting>> getSettings({required SettingKind kind}) =>
      RustLib.instance.api
          .crateApiExtensionProxyExtensionGetSettings(that: this, kind: kind);

  Future<bool> handleUrl({required String url, CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionHandleUrl(
          that: this, url: url, token: token);

  Future<bool> hasPermission({required Permission permission}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionHasPermission(
          that: this, permission: permission);

  Future<void> invalidate({required String domain}) => RustLib.instance.api
      .crateApiExtensionProxyExtensionInvalidate(that: this, domain: domain);

  Future<bool> isEnabled() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionIsEnabled(
        that: this,
      );

  Future<bool> isLoggedIn({required String domain}) => RustLib.instance.api
      .crateApiExtensionProxyExtensionIsLoggedIn(that: this, domain: domain);

  Future<EntryDetailedResult> mapEntry(
          {required EntryDetailed entry,
          required Map<String, Setting> settings,
          CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionMapEntry(
          that: this, entry: entry, settings: settings, token: token);

  Future<SourceResult> mapSource(
          {required Source source,
          required EpisodeId epid,
          required Map<String, Setting> settings,
          CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionMapSource(
          that: this,
          source: source,
          epid: epid,
          settings: settings,
          token: token);

  Future<void> mergeAuth({required Account account}) => RustLib.instance.api
      .crateApiExtensionProxyExtensionMergeAuth(that: this, account: account);

  Future<void> mergeSettingDefinition(
          {required String id,
          required SettingKind kind,
          required Setting definition}) =>
      RustLib.instance.api
          .crateApiExtensionProxyExtensionMergeSettingDefinition(
              that: this, id: id, kind: kind, definition: definition);

  Future<void> onEntryActivity(
          {required EntryActivity activity,
          required EntryDetailed entry,
          required Map<String, Setting> settings,
          CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionOnEntryActivity(
          that: this,
          activity: activity,
          entry: entry,
          settings: settings,
          token: token);

  Future<void> reload() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionReload(
        that: this,
      );

  Future<void> removePermission({required Permission permission}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionRemovePermission(
          that: this, permission: permission);

  Future<void> removeSetting({required String id, required SettingKind kind}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionRemoveSetting(
          that: this, id: id, kind: kind);

  Future<void> saveAuthState() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionSaveAuthState(
        that: this,
      );

  Future<void> savePermissions() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionSavePermissions(
        that: this,
      );

  Future<void> saveSettings() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionSaveSettings(
        that: this,
      );

  Future<EntryList> search(
          {required int page, required String filter, CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionSearch(
          that: this, page: page, filter: filter, token: token);

  Future<void> setEnabled({required bool enabled}) => RustLib.instance.api
      .crateApiExtensionProxyExtensionSetEnabled(that: this, enabled: enabled);

  Future<void> setSetting(
          {required String id,
          required SettingKind kind,
          required SettingValue value}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionSetSetting(
          that: this, id: id, kind: kind, value: value);

  Future<SourceResult> source(
          {required EpisodeId epid,
          required Map<String, Setting> settings,
          CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionSource(
          that: this, epid: epid, settings: settings, token: token);

  Future<Account?> validate({required Account account, CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionValidate(
          that: this, account: account, token: token);
}
