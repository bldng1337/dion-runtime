// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

import 'dart:convert';

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/cancel.dart';
import 'api/client.dart';
import 'api/extension.dart';
import 'dart:async';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'third_party/dion_runtime/datastructs.dart';
import 'third_party/dion_runtime/permission.dart';
import 'third_party/dion_runtime/settings.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiLetsInitAppHere();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => -187761305;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rdion_runtime',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateApiCancelCancelTokenCancel({required CancelToken that});

  Future<CancelToken> crateApiCancelCancelTokenGetChild(
      {required CancelToken that});

  Future<bool> crateApiCancelCancelTokenIsCancelled(
      {required CancelToken that});

  CancelToken crateApiCancelCancelTokenNew();

  Future<ExtensionClient> crateApiClientExtensionClientInit(
      {required FutureOr<String> Function(String) loadData,
      required FutureOr<void> Function(String, String) storeData,
      required FutureOr<void> Function(Action) doAction,
      required FutureOr<bool> Function(Permission, String?) requestPermission,
      required FutureOr<String> Function() getPath});

  Future<ManagerClient> crateApiClientManagerClientInit(
      {required FutureOr<String> Function() getPath,
      required FutureOr<ExtensionClient> Function(ExtensionData) getClient});

  Future<List<ProxyExtension>>
      crateApiExtensionProxyExtensionManagerGetExtensions(
          {required ProxyExtensionManager that});

  Future<ExtensionRepo> crateApiExtensionProxyExtensionManagerGetRepo(
      {required ProxyExtensionManager that, required String url});

  Future<ProxyExtensionManager> crateApiExtensionProxyExtensionManagerInitDion(
      {required ManagerClient client});

  Future<ProxyExtension> crateApiExtensionProxyExtensionManagerInstall(
      {required ProxyExtensionManager that, required RemoteExtension location});

  Future<ProxyExtension> crateApiExtensionProxyExtensionManagerInstallSingle(
      {required ProxyExtensionManager that, required String url});

  Future<void> crateApiExtensionProxyExtensionManagerUninstall(
      {required ProxyExtensionManager that, required ProxyExtension ext});

  Future<EntryList> crateApiExtensionProxyExtensionBrowse(
      {required ProxyExtension that, required int page, CancelToken? token});

  Future<EntryDetailedResult> crateApiExtensionProxyExtensionDetail(
      {required ProxyExtension that,
      required String entryid,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<bool> crateApiExtensionProxyExtensionFromurl(
      {required ProxyExtension that, required String url, CancelToken? token});

  Future<ExtensionData> crateApiExtensionProxyExtensionGetExtensionData(
      {required ProxyExtension that});

  Future<List<Permission>> crateApiExtensionProxyExtensionGetPermissions(
      {required ProxyExtension that});

  Future<Setting> crateApiExtensionProxyExtensionGetSetting(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind});

  Future<List<String>> crateApiExtensionProxyExtensionGetSettingIds(
      {required ProxyExtension that, required SettingKind kind});

  Future<Map<String, Setting>> crateApiExtensionProxyExtensionGetSettings(
      {required ProxyExtension that, required SettingKind kind});

  Future<bool> crateApiExtensionProxyExtensionHasPermission(
      {required ProxyExtension that, required Permission permission});

  Future<bool> crateApiExtensionProxyExtensionIsEnabled(
      {required ProxyExtension that});

  Future<EntryDetailedResult> crateApiExtensionProxyExtensionMapEntry(
      {required ProxyExtension that,
      required EntryDetailed entry,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<SourceResult> crateApiExtensionProxyExtensionMapSource(
      {required ProxyExtension that,
      required Source source,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<void> crateApiExtensionProxyExtensionMergeSettingDefinition(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind,
      required Setting definition});

  Future<void> crateApiExtensionProxyExtensionOnEntryActivity(
      {required ProxyExtension that,
      required EntryActivity activity,
      required EntryDetailed entry,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<void> crateApiExtensionProxyExtensionReload(
      {required ProxyExtension that});

  Future<void> crateApiExtensionProxyExtensionRemovePermission(
      {required ProxyExtension that, required Permission permission});

  Future<void> crateApiExtensionProxyExtensionRemoveSetting(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind});

  Future<EntryList> crateApiExtensionProxyExtensionSearch(
      {required ProxyExtension that,
      required int page,
      required String filter,
      CancelToken? token});

  Future<void> crateApiExtensionProxyExtensionSetEnabled(
      {required ProxyExtension that, required bool enabled});

  Future<void> crateApiExtensionProxyExtensionSetSetting(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind,
      required SettingValue value});

  Future<SourceResult> crateApiExtensionProxyExtensionSource(
      {required ProxyExtension that,
      required String epid,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<Entry> dionRuntimeDatastructsEntryDefault();

  Future<EntryDetailed> dionRuntimeDatastructsEntryDetailedDefault();

  Future<EntryDetailedResult>
      dionRuntimeDatastructsEntryDetailedResultDefault();

  Future<EntryList> dionRuntimeDatastructsEntryListDefault();

  Future<Episode> dionRuntimeDatastructsEpisodeDefault();

  Future<ExtensionData> dionRuntimeDatastructsExtensionDataDefault();

  Future<ExtensionRepo> dionRuntimeDatastructsExtensionRepoDefault();

  Future<void> crateApiLetsInitAppHere();

  Future<Link> dionRuntimeDatastructsLinkDefault();

  Future<MediaType> dionRuntimeDatastructsMediaTypeDefault();

  Future<ReleaseStatus> dionRuntimeDatastructsReleaseStatusDefault();

  Future<RemoteExtension> dionRuntimeDatastructsRemoteExtensionDefault();

  Future<TimestampType> dionRuntimeDatastructsTimestampTypeDefault();

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_CancelToken;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_CancelToken;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_CancelTokenPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExtensionClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExtensionClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ExtensionClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ManagerClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ManagerClient;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ManagerClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProxyExtension;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProxyExtension;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ProxyExtensionPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProxyExtensionManager;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProxyExtensionManager;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ProxyExtensionManagerPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateApiCancelCancelTokenCancel({required CancelToken that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
                that);
        return wire.wire__crate__api__cancel__CancelToken_cancel(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCancelCancelTokenCancelConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCancelCancelTokenCancelConstMeta =>
      const TaskConstMeta(
        debugName: "CancelToken_cancel",
        argNames: ["that"],
      );

  @override
  Future<CancelToken> crateApiCancelCancelTokenGetChild(
      {required CancelToken that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
                that);
        return wire.wire__crate__api__cancel__CancelToken_get_child(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCancelCancelTokenGetChildConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCancelCancelTokenGetChildConstMeta =>
      const TaskConstMeta(
        debugName: "CancelToken_get_child",
        argNames: ["that"],
      );

  @override
  Future<bool> crateApiCancelCancelTokenIsCancelled(
      {required CancelToken that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
                that);
        return wire.wire__crate__api__cancel__CancelToken_is_cancelled(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCancelCancelTokenIsCancelledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCancelCancelTokenIsCancelledConstMeta =>
      const TaskConstMeta(
        debugName: "CancelToken_is_cancelled",
        argNames: ["that"],
      );

  @override
  CancelToken crateApiCancelCancelTokenNew() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        return wire.wire__crate__api__cancel__CancelToken_new();
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiCancelCancelTokenNewConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiCancelCancelTokenNewConstMeta =>
      const TaskConstMeta(
        debugName: "CancelToken_new",
        argNames: [],
      );

  @override
  Future<ExtensionClient> crateApiClientExtensionClientInit(
      {required FutureOr<String> Function(String) loadData,
      required FutureOr<void> Function(String, String) storeData,
      required FutureOr<void> Function(Action) doAction,
      required FutureOr<bool> Function(Permission, String?) requestPermission,
      required FutureOr<String> Function() getPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_DartFn_Inputs_String_Output_String_AnyhowException(
            loadData, serializer);
        sse_encode_DartFn_Inputs_String_String_Output_unit_AnyhowException(
            storeData, serializer);
        sse_encode_DartFn_Inputs_action_Output_unit_AnyhowException(
            doAction, serializer);
        sse_encode_DartFn_Inputs_permission_opt_String_Output_bool_AnyhowException(
            requestPermission, serializer);
        sse_encode_DartFn_Inputs__Output_String_AnyhowException(
            getPath, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__client__ExtensionClient_init(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiClientExtensionClientInitConstMeta,
      argValues: [loadData, storeData, doAction, requestPermission, getPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiClientExtensionClientInitConstMeta =>
      const TaskConstMeta(
        debugName: "ExtensionClient_init",
        argNames: [
          "loadData",
          "storeData",
          "doAction",
          "requestPermission",
          "getPath"
        ],
      );

  @override
  Future<ManagerClient> crateApiClientManagerClientInit(
      {required FutureOr<String> Function() getPath,
      required FutureOr<ExtensionClient> Function(ExtensionData) getClient}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_DartFn_Inputs__Output_String_AnyhowException(
            getPath, serializer);
        sse_encode_DartFn_Inputs_extension_data_Output_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient_AnyhowException(
            getClient, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__client__ManagerClient_init(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiClientManagerClientInitConstMeta,
      argValues: [getPath, getClient],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiClientManagerClientInitConstMeta =>
      const TaskConstMeta(
        debugName: "ManagerClient_init",
        argNames: ["getPath", "getClient"],
      );

  @override
  Future<List<ProxyExtension>>
      crateApiExtensionProxyExtensionManagerGetExtensions(
          {required ProxyExtensionManager that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
                that);
        return wire
            .wire__crate__api__extension__ProxyExtensionManager_get_extensions(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionManagerGetExtensionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiExtensionProxyExtensionManagerGetExtensionsConstMeta =>
          const TaskConstMeta(
            debugName: "ProxyExtensionManager_get_extensions",
            argNames: ["that"],
          );

  @override
  Future<ExtensionRepo> crateApiExtensionProxyExtensionManagerGetRepo(
      {required ProxyExtensionManager that, required String url}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
                that);
        var arg1 = cst_encode_String(url);
        return wire.wire__crate__api__extension__ProxyExtensionManager_get_repo(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_extension_repo,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionManagerGetRepoConstMeta,
      argValues: [that, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionManagerGetRepoConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtensionManager_get_repo",
        argNames: ["that", "url"],
      );

  @override
  Future<ProxyExtensionManager> crateApiExtensionProxyExtensionManagerInitDion(
      {required ManagerClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
                client);
        return wire
            .wire__crate__api__extension__ProxyExtensionManager_init_dion(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionManagerInitDionConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionManagerInitDionConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtensionManager_init_dion",
        argNames: ["client"],
      );

  @override
  Future<ProxyExtension> crateApiExtensionProxyExtensionManagerInstall(
      {required ProxyExtensionManager that,
      required RemoteExtension location}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
                that);
        var arg1 = cst_encode_box_autoadd_remote_extension(location);
        return wire.wire__crate__api__extension__ProxyExtensionManager_install(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionManagerInstallConstMeta,
      argValues: [that, location],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionManagerInstallConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtensionManager_install",
        argNames: ["that", "location"],
      );

  @override
  Future<ProxyExtension> crateApiExtensionProxyExtensionManagerInstallSingle(
      {required ProxyExtensionManager that, required String url}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
                that);
        var arg1 = cst_encode_String(url);
        return wire
            .wire__crate__api__extension__ProxyExtensionManager_install_single(
                port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionManagerInstallSingleConstMeta,
      argValues: [that, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiExtensionProxyExtensionManagerInstallSingleConstMeta =>
          const TaskConstMeta(
            debugName: "ProxyExtensionManager_install_single",
            argNames: ["that", "url"],
          );

  @override
  Future<void> crateApiExtensionProxyExtensionManagerUninstall(
      {required ProxyExtensionManager that, required ProxyExtension ext}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
                that);
        var arg1 =
            cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                ext);
        return wire
            .wire__crate__api__extension__ProxyExtensionManager_uninstall(
                port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionManagerUninstallConstMeta,
      argValues: [that, ext],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionManagerUninstallConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtensionManager_uninstall",
        argNames: ["that", "ext"],
      );

  @override
  Future<EntryList> crateApiExtensionProxyExtensionBrowse(
      {required ProxyExtension that, required int page, CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_i_32(page, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_browse(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_entry_list,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionBrowseConstMeta,
      argValues: [that, page, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionBrowseConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_browse",
        argNames: ["that", "page", "token"],
      );

  @override
  Future<EntryDetailedResult> crateApiExtensionProxyExtensionDetail(
      {required ProxyExtension that,
      required String entryid,
      required Map<String, Setting> settings,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_String(entryid, serializer);
        sse_encode_Map_String_setting_None(settings, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_detail(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_entry_detailed_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionDetailConstMeta,
      argValues: [that, entryid, settings, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionDetailConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_detail",
        argNames: ["that", "entryid", "settings", "token"],
      );

  @override
  Future<bool> crateApiExtensionProxyExtensionFromurl(
      {required ProxyExtension that, required String url, CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        var arg1 = cst_encode_String(url);
        var arg2 =
            cst_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
                token);
        return wire.wire__crate__api__extension__ProxyExtension_fromurl(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionFromurlConstMeta,
      argValues: [that, url, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionFromurlConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_fromurl",
        argNames: ["that", "url", "token"],
      );

  @override
  Future<ExtensionData> crateApiExtensionProxyExtensionGetExtensionData(
      {required ProxyExtension that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        final raw_ = serializer.intoRaw();
        return wire
            .wire__crate__api__extension__ProxyExtension_get_extension_data(
                port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_extension_data,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionGetExtensionDataConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionGetExtensionDataConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_get_extension_data",
        argNames: ["that"],
      );

  @override
  Future<List<Permission>> crateApiExtensionProxyExtensionGetPermissions(
      {required ProxyExtension that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_get_permissions(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_permission,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionGetPermissionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionGetPermissionsConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_get_permissions",
        argNames: ["that"],
      );

  @override
  Future<Setting> crateApiExtensionProxyExtensionGetSetting(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_String(id, serializer);
        sse_encode_setting_kind(kind, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_get_setting(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_setting,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionGetSettingConstMeta,
      argValues: [that, id, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionGetSettingConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_get_setting",
        argNames: ["that", "id", "kind"],
      );

  @override
  Future<List<String>> crateApiExtensionProxyExtensionGetSettingIds(
      {required ProxyExtension that, required SettingKind kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_setting_kind(kind, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_get_setting_ids(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiExtensionProxyExtensionGetSettingIdsConstMeta,
      argValues: [that, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionGetSettingIdsConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_get_setting_ids",
        argNames: ["that", "kind"],
      );

  @override
  Future<Map<String, Setting>> crateApiExtensionProxyExtensionGetSettings(
      {required ProxyExtension that, required SettingKind kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_setting_kind(kind, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_get_settings(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Map_String_setting_None,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionGetSettingsConstMeta,
      argValues: [that, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionGetSettingsConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_get_settings",
        argNames: ["that", "kind"],
      );

  @override
  Future<bool> crateApiExtensionProxyExtensionHasPermission(
      {required ProxyExtension that, required Permission permission}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_permission(permission, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_has_permission(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiExtensionProxyExtensionHasPermissionConstMeta,
      argValues: [that, permission],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionHasPermissionConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_has_permission",
        argNames: ["that", "permission"],
      );

  @override
  Future<bool> crateApiExtensionProxyExtensionIsEnabled(
      {required ProxyExtension that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        return wire.wire__crate__api__extension__ProxyExtension_is_enabled(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiExtensionProxyExtensionIsEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionIsEnabledConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_is_enabled",
        argNames: ["that"],
      );

  @override
  Future<EntryDetailedResult> crateApiExtensionProxyExtensionMapEntry(
      {required ProxyExtension that,
      required EntryDetailed entry,
      required Map<String, Setting> settings,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_entry_detailed(entry, serializer);
        sse_encode_Map_String_setting_None(settings, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_map_entry(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_entry_detailed_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionMapEntryConstMeta,
      argValues: [that, entry, settings, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionMapEntryConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_map_entry",
        argNames: ["that", "entry", "settings", "token"],
      );

  @override
  Future<SourceResult> crateApiExtensionProxyExtensionMapSource(
      {required ProxyExtension that,
      required Source source,
      required Map<String, Setting> settings,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_source(source, serializer);
        sse_encode_Map_String_setting_None(settings, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_map_source(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_source_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionMapSourceConstMeta,
      argValues: [that, source, settings, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionMapSourceConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_map_source",
        argNames: ["that", "source", "settings", "token"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionMergeSettingDefinition(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind,
      required Setting definition}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_String(id, serializer);
        sse_encode_setting_kind(kind, serializer);
        sse_encode_box_autoadd_setting(definition, serializer);
        final raw_ = serializer.intoRaw();
        return wire
            .wire__crate__api__extension__ProxyExtension_merge_setting_definition(
                port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta:
          kCrateApiExtensionProxyExtensionMergeSettingDefinitionConstMeta,
      argValues: [that, id, kind, definition],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiExtensionProxyExtensionMergeSettingDefinitionConstMeta =>
          const TaskConstMeta(
            debugName: "ProxyExtension_merge_setting_definition",
            argNames: ["that", "id", "kind", "definition"],
          );

  @override
  Future<void> crateApiExtensionProxyExtensionOnEntryActivity(
      {required ProxyExtension that,
      required EntryActivity activity,
      required EntryDetailed entry,
      required Map<String, Setting> settings,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_entry_activity(activity, serializer);
        sse_encode_box_autoadd_entry_detailed(entry, serializer);
        sse_encode_Map_String_setting_None(settings, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire
            .wire__crate__api__extension__ProxyExtension_on_entry_activity(
                port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionOnEntryActivityConstMeta,
      argValues: [that, activity, entry, settings, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionOnEntryActivityConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_on_entry_activity",
        argNames: ["that", "activity", "entry", "settings", "token"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionReload(
      {required ProxyExtension that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        return wire.wire__crate__api__extension__ProxyExtension_reload(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionReloadConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionReloadConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_reload",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionRemovePermission(
      {required ProxyExtension that, required Permission permission}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_box_autoadd_permission(permission, serializer);
        final raw_ = serializer.intoRaw();
        return wire
            .wire__crate__api__extension__ProxyExtension_remove_permission(
                port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionRemovePermissionConstMeta,
      argValues: [that, permission],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionRemovePermissionConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_remove_permission",
        argNames: ["that", "permission"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionRemoveSetting(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_String(id, serializer);
        sse_encode_setting_kind(kind, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_remove_setting(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionRemoveSettingConstMeta,
      argValues: [that, id, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionRemoveSettingConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_remove_setting",
        argNames: ["that", "id", "kind"],
      );

  @override
  Future<EntryList> crateApiExtensionProxyExtensionSearch(
      {required ProxyExtension that,
      required int page,
      required String filter,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_i_32(page, serializer);
        sse_encode_String(filter, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_search(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_entry_list,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionSearchConstMeta,
      argValues: [that, page, filter, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionSearchConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_search",
        argNames: ["that", "page", "filter", "token"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionSetEnabled(
      {required ProxyExtension that, required bool enabled}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
                that);
        var arg1 = cst_encode_bool(enabled);
        return wire.wire__crate__api__extension__ProxyExtension_set_enabled(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionSetEnabledConstMeta,
      argValues: [that, enabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionSetEnabledConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_set_enabled",
        argNames: ["that", "enabled"],
      );

  @override
  Future<void> crateApiExtensionProxyExtensionSetSetting(
      {required ProxyExtension that,
      required String id,
      required SettingKind kind,
      required SettingValue value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_String(id, serializer);
        sse_encode_setting_kind(kind, serializer);
        sse_encode_box_autoadd_setting_value(value, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_set_setting(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionSetSettingConstMeta,
      argValues: [that, id, kind, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionSetSettingConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_set_setting",
        argNames: ["that", "id", "kind", "value"],
      );

  @override
  Future<SourceResult> crateApiExtensionProxyExtensionSource(
      {required ProxyExtension that,
      required String epid,
      required Map<String, Setting> settings,
      CancelToken? token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
            that, serializer);
        sse_encode_String(epid, serializer);
        sse_encode_Map_String_setting_None(settings, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            token, serializer);
        final raw_ = serializer.intoRaw();
        return wire.wire__crate__api__extension__ProxyExtension_source(
            port_, raw_.ptr, raw_.rustVecLen, raw_.dataLen);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_source_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiExtensionProxyExtensionSourceConstMeta,
      argValues: [that, epid, settings, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiExtensionProxyExtensionSourceConstMeta =>
      const TaskConstMeta(
        debugName: "ProxyExtension_source",
        argNames: ["that", "epid", "settings", "token"],
      );

  @override
  Future<Entry> dionRuntimeDatastructsEntryDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__dion_runtime__datastructs__entry_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_entry,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDatastructsEntryDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDatastructsEntryDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "entry_default",
        argNames: [],
      );

  @override
  Future<EntryDetailed> dionRuntimeDatastructsEntryDetailedDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__datastructs__entry_detailed_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_entry_detailed,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDatastructsEntryDetailedDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDatastructsEntryDetailedDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "entry_detailed_default",
        argNames: [],
      );

  @override
  Future<EntryDetailedResult>
      dionRuntimeDatastructsEntryDetailedResultDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__datastructs__entry_detailed_result_default(
                port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_entry_detailed_result,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDatastructsEntryDetailedResultDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kDionRuntimeDatastructsEntryDetailedResultDefaultConstMeta =>
          const TaskConstMeta(
            debugName: "entry_detailed_result_default",
            argNames: [],
          );

  @override
  Future<EntryList> dionRuntimeDatastructsEntryListDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__dion_runtime__datastructs__entry_list_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_entry_list,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDatastructsEntryListDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDatastructsEntryListDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "entry_list_default",
        argNames: [],
      );

  @override
  Future<Episode> dionRuntimeDatastructsEpisodeDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__dion_runtime__datastructs__episode_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_episode,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDatastructsEpisodeDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDatastructsEpisodeDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "episode_default",
        argNames: [],
      );

  @override
  Future<ExtensionData> dionRuntimeDatastructsExtensionDataDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__datastructs__extension_data_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_extension_data,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDatastructsExtensionDataDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDatastructsExtensionDataDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "extension_data_default",
        argNames: [],
      );

  @override
  Future<ExtensionRepo> dionRuntimeDatastructsExtensionRepoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__datastructs__extension_repo_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_extension_repo,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDatastructsExtensionRepoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDatastructsExtensionRepoDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "extension_repo_default",
        argNames: [],
      );

  @override
  Future<void> crateApiLetsInitAppHere() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__lets_init_app_here(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiLetsInitAppHereConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLetsInitAppHereConstMeta => const TaskConstMeta(
        debugName: "lets_init_app_here",
        argNames: [],
      );

  @override
  Future<Link> dionRuntimeDatastructsLinkDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__dion_runtime__datastructs__link_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_link,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDatastructsLinkDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDatastructsLinkDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "link_default",
        argNames: [],
      );

  @override
  Future<MediaType> dionRuntimeDatastructsMediaTypeDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__dion_runtime__datastructs__media_type_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_media_type,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDatastructsMediaTypeDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDatastructsMediaTypeDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "media_type_default",
        argNames: [],
      );

  @override
  Future<ReleaseStatus> dionRuntimeDatastructsReleaseStatusDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__datastructs__release_status_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_release_status,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDatastructsReleaseStatusDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDatastructsReleaseStatusDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "release_status_default",
        argNames: [],
      );

  @override
  Future<RemoteExtension> dionRuntimeDatastructsRemoteExtensionDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__datastructs__remote_extension_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_remote_extension,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDatastructsRemoteExtensionDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDatastructsRemoteExtensionDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "remote_extension_default",
        argNames: [],
      );

  @override
  Future<TimestampType> dionRuntimeDatastructsTimestampTypeDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire
            .wire__dion_runtime__datastructs__timestamp_type_default(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_timestamp_type,
        decodeErrorData: null,
      ),
      constMeta: kDionRuntimeDatastructsTimestampTypeDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kDionRuntimeDatastructsTimestampTypeDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "timestamp_type_default",
        argNames: [],
      );

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_String_Output_String_AnyhowException(
          FutureOr<String> Function(String) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_String(rawArg0);

      Box<String>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_String(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic, dynamic)
      encode_DartFn_Inputs_String_String_Output_unit_AnyhowException(
          FutureOr<void> Function(String, String) raw) {
    return (callId, rawArg0, rawArg1) async {
      final arg0 = dco_decode_String(rawArg0);
      final arg1 = dco_decode_String(rawArg1);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0, arg1));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(
    int,
  ) encode_DartFn_Inputs__Output_String_AnyhowException(
      FutureOr<String> Function() raw) {
    return (
      callId,
    ) async {
      Box<String>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw());
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_String(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_action_Output_unit_AnyhowException(
          FutureOr<void> Function(Action) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_action(rawArg0);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_extension_data_Output_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient_AnyhowException(
          FutureOr<ExtensionClient> Function(ExtensionData) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_extension_data(rawArg0);

      Box<ExtensionClient>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
            rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic, dynamic)
      encode_DartFn_Inputs_permission_opt_String_Output_bool_AnyhowException(
          FutureOr<bool> Function(Permission, String?) raw) {
    return (callId, rawArg0, rawArg1) async {
      final arg0 = dco_decode_permission(rawArg0);
      final arg1 = dco_decode_opt_String(rawArg1);

      Box<bool>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0, arg1));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_bool(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_CancelToken => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_CancelToken => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ExtensionClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ExtensionClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ManagerClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ManagerClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProxyExtension => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProxyExtension => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProxyExtensionManager => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProxyExtensionManager => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  CancelToken
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CancelTokenImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtensionClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtensionClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ManagerClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ManagerClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyExtension
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyExtensionManager
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyExtensionManagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyExtension
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  CancelToken
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CancelTokenImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ManagerClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ManagerClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyExtension
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyExtensionManager
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyExtensionManagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FutureOr<String> Function(String)
      dco_decode_DartFn_Inputs_String_Output_String_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<void> Function(String, String)
      dco_decode_DartFn_Inputs_String_String_Output_unit_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<String> Function()
      dco_decode_DartFn_Inputs__Output_String_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<void> Function(Action)
      dco_decode_DartFn_Inputs_action_Output_unit_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<ExtensionClient> Function(ExtensionData)
      dco_decode_DartFn_Inputs_extension_data_Output_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<bool> Function(Permission, String?)
      dco_decode_DartFn_Inputs_permission_opt_String_Output_bool_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  Object dco_decode_DartOpaque(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return decodeDartOpaque(raw, generalizedFrbRustBinding);
  }

  @protected
  Map<String, String> dco_decode_Map_String_String_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_string(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, Setting> dco_decode_Map_String_setting_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_setting(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  CancelToken
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CancelTokenImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ExtensionClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtensionClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ManagerClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ManagerClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyExtension
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProxyExtensionManager
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProxyExtensionManagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Action dco_decode_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Action_OpenBrowser(
          url: dco_decode_String(raw[1]),
        );
      case 1:
        return Action_Popup(
          title: dco_decode_String(raw[1]),
          content: dco_decode_box_autoadd_custom_ui(raw[2]),
          actions: dco_decode_list_popup_action(raw[3]),
        );
      case 2:
        return Action_Nav(
          title: dco_decode_String(raw[1]),
          content: dco_decode_box_autoadd_custom_ui(raw[2]),
        );
      case 3:
        return Action_TriggerEvent(
          event: dco_decode_String(raw[1]),
          data: dco_decode_String(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Action dco_decode_box_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_action(raw);
  }

  @protected
  CancelToken
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
        raw);
  }

  @protected
  Action dco_decode_box_autoadd_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_action(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  CustomUI dco_decode_box_autoadd_custom_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_custom_ui(raw);
  }

  @protected
  Entry dco_decode_box_autoadd_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_entry(raw);
  }

  @protected
  EntryActivity dco_decode_box_autoadd_entry_activity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_entry_activity(raw);
  }

  @protected
  EntryDetailed dco_decode_box_autoadd_entry_detailed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_entry_detailed(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  Link dco_decode_box_autoadd_link(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_link(raw);
  }

  @protected
  Permission dco_decode_box_autoadd_permission(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_permission(raw);
  }

  @protected
  RemoteExtension dco_decode_box_autoadd_remote_extension(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_remote_extension(raw);
  }

  @protected
  Setting dco_decode_box_autoadd_setting(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_setting(raw);
  }

  @protected
  SettingValue dco_decode_box_autoadd_setting_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_setting_value(raw);
  }

  @protected
  SettingsUI dco_decode_box_autoadd_settings_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_settings_ui(raw);
  }

  @protected
  Source dco_decode_box_autoadd_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_source(raw);
  }

  @protected
  CustomUI dco_decode_box_custom_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_custom_ui(raw);
  }

  @protected
  UIAction dco_decode_box_ui_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_ui_action(raw);
  }

  @protected
  CustomUI dco_decode_custom_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return CustomUI_Text(
          text: dco_decode_String(raw[1]),
        );
      case 1:
        return CustomUI_Image(
          image: dco_decode_box_autoadd_link(raw[1]),
          width: dco_decode_opt_box_autoadd_i_32(raw[2]),
          height: dco_decode_opt_box_autoadd_i_32(raw[3]),
        );
      case 2:
        return CustomUI_Link(
          link: dco_decode_String(raw[1]),
          label: dco_decode_opt_String(raw[2]),
        );
      case 3:
        return CustomUI_TimeStamp(
          timestamp: dco_decode_String(raw[1]),
          display: dco_decode_timestamp_type(raw[2]),
        );
      case 4:
        return CustomUI_EntryCard(
          entry: dco_decode_box_autoadd_entry(raw[1]),
        );
      case 5:
        return CustomUI_Button(
          label: dco_decode_String(raw[1]),
          onClick: dco_decode_opt_box_ui_action(raw[2]),
        );
      case 6:
        return CustomUI_InlineSetting(
          settingId: dco_decode_String(raw[1]),
          onCommit: dco_decode_opt_box_ui_action(raw[2]),
        );
      case 7:
        return CustomUI_Slot(
          id: dco_decode_String(raw[1]),
          child: dco_decode_box_custom_ui(raw[2]),
        );
      case 8:
        return CustomUI_Column(
          children: dco_decode_list_custom_ui(raw[1]),
        );
      case 9:
        return CustomUI_Row(
          children: dco_decode_list_custom_ui(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  DropdownOption dco_decode_dropdown_option(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return DropdownOption(
      label: dco_decode_String(arr[0]),
      value: dco_decode_String(arr[1]),
    );
  }

  @protected
  Entry dco_decode_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return Entry(
      id: dco_decode_String(arr[0]),
      url: dco_decode_String(arr[1]),
      title: dco_decode_String(arr[2]),
      mediaType: dco_decode_media_type(arr[3]),
      cover: dco_decode_opt_box_autoadd_link(arr[4]),
      author: dco_decode_opt_list_String(arr[5]),
      rating: dco_decode_opt_box_autoadd_f_32(arr[6]),
      views: dco_decode_opt_box_autoadd_f_32(arr[7]),
      length: dco_decode_opt_box_autoadd_i_32(arr[8]),
    );
  }

  @protected
  EntryActivity dco_decode_entry_activity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return EntryActivity_EpisodeActivity(
          progress: dco_decode_i_32(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  EntryDetailed dco_decode_entry_detailed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 16)
      throw Exception('unexpected arr length: expect 16 but see ${arr.length}');
    return EntryDetailed(
      id: dco_decode_String(arr[0]),
      url: dco_decode_String(arr[1]),
      titles: dco_decode_list_String(arr[2]),
      author: dco_decode_opt_list_String(arr[3]),
      ui: dco_decode_opt_box_autoadd_custom_ui(arr[4]),
      meta: dco_decode_opt_Map_String_String_None(arr[5]),
      mediaType: dco_decode_media_type(arr[6]),
      status: dco_decode_release_status(arr[7]),
      description: dco_decode_String(arr[8]),
      language: dco_decode_String(arr[9]),
      cover: dco_decode_opt_box_autoadd_link(arr[10]),
      episodes: dco_decode_list_episode(arr[11]),
      genres: dco_decode_opt_list_String(arr[12]),
      rating: dco_decode_opt_box_autoadd_f_32(arr[13]),
      views: dco_decode_opt_box_autoadd_f_32(arr[14]),
      length: dco_decode_opt_box_autoadd_i_32(arr[15]),
    );
  }

  @protected
  EntryDetailedResult dco_decode_entry_detailed_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return EntryDetailedResult(
      entry: dco_decode_entry_detailed(arr[0]),
      settings: dco_decode_Map_String_setting_None(arr[1]),
    );
  }

  @protected
  EntryList dco_decode_entry_list(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return EntryList(
      hasnext: dco_decode_opt_box_autoadd_bool(arr[0]),
      length: dco_decode_opt_box_autoadd_i_32(arr[1]),
      content: dco_decode_list_entry(arr[2]),
    );
  }

  @protected
  Episode dco_decode_episode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return Episode(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      description: dco_decode_opt_String(arr[2]),
      url: dco_decode_String(arr[3]),
      cover: dco_decode_opt_box_autoadd_link(arr[4]),
      timestamp: dco_decode_opt_String(arr[5]),
    );
  }

  @protected
  ExtensionData dco_decode_extension_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 14)
      throw Exception('unexpected arr length: expect 14 but see ${arr.length}');
    return ExtensionData(
      id: dco_decode_String(arr[0]),
      repo: dco_decode_opt_String(arr[1]),
      name: dco_decode_String(arr[2]),
      mediaType: dco_decode_opt_list_media_type(arr[3]),
      extensionType: dco_decode_opt_list_extension_type(arr[4]),
      version: dco_decode_opt_String(arr[5]),
      desc: dco_decode_opt_String(arr[6]),
      author: dco_decode_list_String(arr[7]),
      license: dco_decode_opt_String(arr[8]),
      tags: dco_decode_opt_list_String(arr[9]),
      nsfw: dco_decode_opt_box_autoadd_bool(arr[10]),
      lang: dco_decode_list_String(arr[11]),
      url: dco_decode_opt_String(arr[12]),
      icon: dco_decode_opt_String(arr[13]),
    );
  }

  @protected
  ExtensionRepo dco_decode_extension_repo(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ExtensionRepo(
      name: dco_decode_String(arr[0]),
      description: dco_decode_String(arr[1]),
      id: dco_decode_String(arr[2]),
      extensions: dco_decode_list_remote_extension(arr[3]),
    );
  }

  @protected
  ExtensionType dco_decode_extension_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExtensionType.values[raw as int];
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ImageListAudio dco_decode_image_list_audio(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ImageListAudio(
      link: dco_decode_link(arr[0]),
      from: dco_decode_i_32(arr[1]),
      to: dco_decode_i_32(arr[2]),
    );
  }

  @protected
  PlatformInt64 dco_decode_isize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  Link dco_decode_link(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Link(
      url: dco_decode_String(arr[0]),
      header: dco_decode_opt_Map_String_String_None(arr[1]),
    );
  }

  @protected
  List<ProxyExtension>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension)
        .toList();
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<CustomUI> dco_decode_list_custom_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_custom_ui).toList();
  }

  @protected
  List<DropdownOption> dco_decode_list_dropdown_option(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_dropdown_option).toList();
  }

  @protected
  List<Entry> dco_decode_list_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_entry).toList();
  }

  @protected
  List<Episode> dco_decode_list_episode(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_episode).toList();
  }

  @protected
  List<ExtensionType> dco_decode_list_extension_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_extension_type).toList();
  }

  @protected
  List<ImageListAudio> dco_decode_list_image_list_audio(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_image_list_audio).toList();
  }

  @protected
  List<Link> dco_decode_list_link(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_link).toList();
  }

  @protected
  List<MediaType> dco_decode_list_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_media_type).toList();
  }

  @protected
  List<Mp3Chapter> dco_decode_list_mp_3_chapter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_mp_3_chapter).toList();
  }

  @protected
  List<Paragraph> dco_decode_list_paragraph(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_paragraph).toList();
  }

  @protected
  List<Permission> dco_decode_list_permission(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_permission).toList();
  }

  @protected
  List<PopupAction> dco_decode_list_popup_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_popup_action).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String, Setting)> dco_decode_list_record_string_setting(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_setting)
        .toList();
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<RemoteExtension> dco_decode_list_remote_extension(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_remote_extension).toList();
  }

  @protected
  List<Subtitles> dco_decode_list_subtitles(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_subtitles).toList();
  }

  @protected
  MediaType dco_decode_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaType.values[raw as int];
  }

  @protected
  Mp3Chapter dco_decode_mp_3_chapter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Mp3Chapter(
      title: dco_decode_String(arr[0]),
      url: dco_decode_link(arr[1]),
    );
  }

  @protected
  Map<String, String>? dco_decode_opt_Map_String_String_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_Map_String_String_None(raw);
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  CancelToken?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
            raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  CustomUI? dco_decode_opt_box_autoadd_custom_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_custom_ui(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  Link? dco_decode_opt_box_autoadd_link(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_link(raw);
  }

  @protected
  SettingsUI? dco_decode_opt_box_autoadd_settings_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_settings_ui(raw);
  }

  @protected
  UIAction? dco_decode_opt_box_ui_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_ui_action(raw);
  }

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_String(raw);
  }

  @protected
  List<ExtensionType>? dco_decode_opt_list_extension_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_extension_type(raw);
  }

  @protected
  List<ImageListAudio>? dco_decode_opt_list_image_list_audio(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_image_list_audio(raw);
  }

  @protected
  List<MediaType>? dco_decode_opt_list_media_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_media_type(raw);
  }

  @protected
  Paragraph dco_decode_paragraph(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Paragraph_Text(
          content: dco_decode_String(raw[1]),
        );
      case 1:
        return Paragraph_CustomUI(
          ui: dco_decode_box_custom_ui(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Permission dco_decode_permission(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Permission_Storage(
          path: dco_decode_String(raw[1]),
          write: dco_decode_bool(raw[2]),
        );
      case 1:
        return Permission_Network(
          domain: dco_decode_String(raw[1]),
        );
      case 2:
        return const Permission_ActionPopup();
      case 3:
        return const Permission_ArbitraryNetwork();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PopupAction dco_decode_popup_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PopupAction(
      label: dco_decode_String(arr[0]),
      onclick: dco_decode_box_action(arr[1]),
    );
  }

  @protected
  (String, Setting) dco_decode_record_string_setting(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_setting(arr[1]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  ReleaseStatus dco_decode_release_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ReleaseStatus.values[raw as int];
  }

  @protected
  RemoteExtension dco_decode_remote_extension(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return RemoteExtension(
      extensionUrl: dco_decode_String(arr[0]),
      compatible: dco_decode_bool(arr[1]),
      data: dco_decode_extension_data(arr[2]),
    );
  }

  @protected
  Setting dco_decode_setting(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return Setting(
      label: dco_decode_String(arr[0]),
      value: dco_decode_setting_value(arr[1]),
      default_: dco_decode_setting_value(arr[2]),
      visible: dco_decode_bool(arr[3]),
      ui: dco_decode_opt_box_autoadd_settings_ui(arr[4]),
    );
  }

  @protected
  SettingKind dco_decode_setting_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SettingKind.values[raw as int];
  }

  @protected
  SettingValue dco_decode_setting_value(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SettingValue_String(
          data: dco_decode_String(raw[1]),
        );
      case 1:
        return SettingValue_Number(
          data: dco_decode_f_32(raw[1]),
        );
      case 2:
        return SettingValue_Boolean(
          data: dco_decode_bool(raw[1]),
        );
      case 3:
        return SettingValue_StringList(
          data: dco_decode_list_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SettingsUI dco_decode_settings_ui(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return const SettingsUI_CheckBox();
      case 1:
        return SettingsUI_Slider(
          min: dco_decode_f_64(raw[1]),
          max: dco_decode_f_64(raw[2]),
          step: dco_decode_i_32(raw[3]),
        );
      case 2:
        return SettingsUI_Dropdown(
          options: dco_decode_list_dropdown_option(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Source dco_decode_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Source_Epub(
          link: dco_decode_box_autoadd_link(raw[1]),
        );
      case 1:
        return Source_Pdf(
          link: dco_decode_box_autoadd_link(raw[1]),
        );
      case 2:
        return Source_Imagelist(
          links: dco_decode_list_link(raw[1]),
          audio: dco_decode_opt_list_image_list_audio(raw[2]),
        );
      case 3:
        return Source_M3u8(
          link: dco_decode_box_autoadd_link(raw[1]),
          sub: dco_decode_list_subtitles(raw[2]),
        );
      case 4:
        return Source_Mp3(
          chapters: dco_decode_list_mp_3_chapter(raw[1]),
        );
      case 5:
        return Source_Paragraphlist(
          paragraphs: dco_decode_list_paragraph(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SourceResult dco_decode_source_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SourceResult(
      source: dco_decode_source(arr[0]),
      settings: dco_decode_Map_String_setting_None(arr[1]),
    );
  }

  @protected
  Subtitles dco_decode_subtitles(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Subtitles(
      title: dco_decode_String(arr[0]),
      url: dco_decode_link(arr[1]),
    );
  }

  @protected
  TimestampType dco_decode_timestamp_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TimestampType.values[raw as int];
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  UIAction dco_decode_ui_action(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return UIAction_Action(
          action: dco_decode_box_autoadd_action(raw[1]),
        );
      case 1:
        return UIAction_SwapContent(
          targetid: dco_decode_opt_String(raw[1]),
          event: dco_decode_String(raw[2]),
          placeholder: dco_decode_opt_box_autoadd_custom_ui(raw[3]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  CancelToken
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CancelTokenImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExtensionClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtensionClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ManagerClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ManagerClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyExtension
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyExtensionManager
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyExtensionManagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyExtension
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  CancelToken
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CancelTokenImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ManagerClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ManagerClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyExtension
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyExtensionManager
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyExtensionManagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Object sse_decode_DartOpaque(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_isize(deserializer);
    return decodeDartOpaque(inner, generalizedFrbRustBinding);
  }

  @protected
  Map<String, String> sse_decode_Map_String_String_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_string(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  Map<String, Setting> sse_decode_Map_String_setting_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_setting(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  CancelToken
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CancelTokenImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ExtensionClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ExtensionClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ManagerClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ManagerClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyExtension
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyExtensionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProxyExtensionManager
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProxyExtensionManagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  Action sse_decode_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_url = sse_decode_String(deserializer);
        return Action_OpenBrowser(url: var_url);
      case 1:
        var var_title = sse_decode_String(deserializer);
        var var_content = sse_decode_box_autoadd_custom_ui(deserializer);
        var var_actions = sse_decode_list_popup_action(deserializer);
        return Action_Popup(
            title: var_title, content: var_content, actions: var_actions);
      case 2:
        var var_title = sse_decode_String(deserializer);
        var var_content = sse_decode_box_autoadd_custom_ui(deserializer);
        return Action_Nav(title: var_title, content: var_content);
      case 3:
        var var_event = sse_decode_String(deserializer);
        var var_data = sse_decode_String(deserializer);
        return Action_TriggerEvent(event: var_event, data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Action sse_decode_box_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_action(deserializer));
  }

  @protected
  CancelToken
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
        deserializer));
  }

  @protected
  Action sse_decode_box_autoadd_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_action(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  CustomUI sse_decode_box_autoadd_custom_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_custom_ui(deserializer));
  }

  @protected
  Entry sse_decode_box_autoadd_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_entry(deserializer));
  }

  @protected
  EntryActivity sse_decode_box_autoadd_entry_activity(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_entry_activity(deserializer));
  }

  @protected
  EntryDetailed sse_decode_box_autoadd_entry_detailed(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_entry_detailed(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  Link sse_decode_box_autoadd_link(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_link(deserializer));
  }

  @protected
  Permission sse_decode_box_autoadd_permission(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_permission(deserializer));
  }

  @protected
  RemoteExtension sse_decode_box_autoadd_remote_extension(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_remote_extension(deserializer));
  }

  @protected
  Setting sse_decode_box_autoadd_setting(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_setting(deserializer));
  }

  @protected
  SettingValue sse_decode_box_autoadd_setting_value(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_setting_value(deserializer));
  }

  @protected
  SettingsUI sse_decode_box_autoadd_settings_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_settings_ui(deserializer));
  }

  @protected
  Source sse_decode_box_autoadd_source(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_source(deserializer));
  }

  @protected
  CustomUI sse_decode_box_custom_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_custom_ui(deserializer));
  }

  @protected
  UIAction sse_decode_box_ui_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_ui_action(deserializer));
  }

  @protected
  CustomUI sse_decode_custom_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_text = sse_decode_String(deserializer);
        return CustomUI_Text(text: var_text);
      case 1:
        var var_image = sse_decode_box_autoadd_link(deserializer);
        var var_width = sse_decode_opt_box_autoadd_i_32(deserializer);
        var var_height = sse_decode_opt_box_autoadd_i_32(deserializer);
        return CustomUI_Image(
            image: var_image, width: var_width, height: var_height);
      case 2:
        var var_link = sse_decode_String(deserializer);
        var var_label = sse_decode_opt_String(deserializer);
        return CustomUI_Link(link: var_link, label: var_label);
      case 3:
        var var_timestamp = sse_decode_String(deserializer);
        var var_display = sse_decode_timestamp_type(deserializer);
        return CustomUI_TimeStamp(
            timestamp: var_timestamp, display: var_display);
      case 4:
        var var_entry = sse_decode_box_autoadd_entry(deserializer);
        return CustomUI_EntryCard(entry: var_entry);
      case 5:
        var var_label = sse_decode_String(deserializer);
        var var_onClick = sse_decode_opt_box_ui_action(deserializer);
        return CustomUI_Button(label: var_label, onClick: var_onClick);
      case 6:
        var var_settingId = sse_decode_String(deserializer);
        var var_onCommit = sse_decode_opt_box_ui_action(deserializer);
        return CustomUI_InlineSetting(
            settingId: var_settingId, onCommit: var_onCommit);
      case 7:
        var var_id = sse_decode_String(deserializer);
        var var_child = sse_decode_box_custom_ui(deserializer);
        return CustomUI_Slot(id: var_id, child: var_child);
      case 8:
        var var_children = sse_decode_list_custom_ui(deserializer);
        return CustomUI_Column(children: var_children);
      case 9:
        var var_children = sse_decode_list_custom_ui(deserializer);
        return CustomUI_Row(children: var_children);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  DropdownOption sse_decode_dropdown_option(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_label = sse_decode_String(deserializer);
    var var_value = sse_decode_String(deserializer);
    return DropdownOption(label: var_label, value: var_value);
  }

  @protected
  Entry sse_decode_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_mediaType = sse_decode_media_type(deserializer);
    var var_cover = sse_decode_opt_box_autoadd_link(deserializer);
    var var_author = sse_decode_opt_list_String(deserializer);
    var var_rating = sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_views = sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_length = sse_decode_opt_box_autoadd_i_32(deserializer);
    return Entry(
        id: var_id,
        url: var_url,
        title: var_title,
        mediaType: var_mediaType,
        cover: var_cover,
        author: var_author,
        rating: var_rating,
        views: var_views,
        length: var_length);
  }

  @protected
  EntryActivity sse_decode_entry_activity(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_progress = sse_decode_i_32(deserializer);
        return EntryActivity_EpisodeActivity(progress: var_progress);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  EntryDetailed sse_decode_entry_detailed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_titles = sse_decode_list_String(deserializer);
    var var_author = sse_decode_opt_list_String(deserializer);
    var var_ui = sse_decode_opt_box_autoadd_custom_ui(deserializer);
    var var_meta = sse_decode_opt_Map_String_String_None(deserializer);
    var var_mediaType = sse_decode_media_type(deserializer);
    var var_status = sse_decode_release_status(deserializer);
    var var_description = sse_decode_String(deserializer);
    var var_language = sse_decode_String(deserializer);
    var var_cover = sse_decode_opt_box_autoadd_link(deserializer);
    var var_episodes = sse_decode_list_episode(deserializer);
    var var_genres = sse_decode_opt_list_String(deserializer);
    var var_rating = sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_views = sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_length = sse_decode_opt_box_autoadd_i_32(deserializer);
    return EntryDetailed(
        id: var_id,
        url: var_url,
        titles: var_titles,
        author: var_author,
        ui: var_ui,
        meta: var_meta,
        mediaType: var_mediaType,
        status: var_status,
        description: var_description,
        language: var_language,
        cover: var_cover,
        episodes: var_episodes,
        genres: var_genres,
        rating: var_rating,
        views: var_views,
        length: var_length);
  }

  @protected
  EntryDetailedResult sse_decode_entry_detailed_result(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_entry = sse_decode_entry_detailed(deserializer);
    var var_settings = sse_decode_Map_String_setting_None(deserializer);
    return EntryDetailedResult(entry: var_entry, settings: var_settings);
  }

  @protected
  EntryList sse_decode_entry_list(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_hasnext = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_length = sse_decode_opt_box_autoadd_i_32(deserializer);
    var var_content = sse_decode_list_entry(deserializer);
    return EntryList(
        hasnext: var_hasnext, length: var_length, content: var_content);
  }

  @protected
  Episode sse_decode_episode(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_description = sse_decode_opt_String(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_cover = sse_decode_opt_box_autoadd_link(deserializer);
    var var_timestamp = sse_decode_opt_String(deserializer);
    return Episode(
        id: var_id,
        name: var_name,
        description: var_description,
        url: var_url,
        cover: var_cover,
        timestamp: var_timestamp);
  }

  @protected
  ExtensionData sse_decode_extension_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_repo = sse_decode_opt_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_mediaType = sse_decode_opt_list_media_type(deserializer);
    var var_extensionType = sse_decode_opt_list_extension_type(deserializer);
    var var_version = sse_decode_opt_String(deserializer);
    var var_desc = sse_decode_opt_String(deserializer);
    var var_author = sse_decode_list_String(deserializer);
    var var_license = sse_decode_opt_String(deserializer);
    var var_tags = sse_decode_opt_list_String(deserializer);
    var var_nsfw = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_lang = sse_decode_list_String(deserializer);
    var var_url = sse_decode_opt_String(deserializer);
    var var_icon = sse_decode_opt_String(deserializer);
    return ExtensionData(
        id: var_id,
        repo: var_repo,
        name: var_name,
        mediaType: var_mediaType,
        extensionType: var_extensionType,
        version: var_version,
        desc: var_desc,
        author: var_author,
        license: var_license,
        tags: var_tags,
        nsfw: var_nsfw,
        lang: var_lang,
        url: var_url,
        icon: var_icon);
  }

  @protected
  ExtensionRepo sse_decode_extension_repo(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_description = sse_decode_String(deserializer);
    var var_id = sse_decode_String(deserializer);
    var var_extensions = sse_decode_list_remote_extension(deserializer);
    return ExtensionRepo(
        name: var_name,
        description: var_description,
        id: var_id,
        extensions: var_extensions);
  }

  @protected
  ExtensionType sse_decode_extension_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ExtensionType.values[inner];
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  ImageListAudio sse_decode_image_list_audio(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_link = sse_decode_link(deserializer);
    var var_from = sse_decode_i_32(deserializer);
    var var_to = sse_decode_i_32(deserializer);
    return ImageListAudio(link: var_link, from: var_from, to: var_to);
  }

  @protected
  PlatformInt64 sse_decode_isize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  Link sse_decode_link(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_header = sse_decode_opt_Map_String_String_None(deserializer);
    return Link(url: var_url, header: var_header);
  }

  @protected
  List<ProxyExtension>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ProxyExtension>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<CustomUI> sse_decode_list_custom_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CustomUI>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_custom_ui(deserializer));
    }
    return ans_;
  }

  @protected
  List<DropdownOption> sse_decode_list_dropdown_option(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DropdownOption>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dropdown_option(deserializer));
    }
    return ans_;
  }

  @protected
  List<Entry> sse_decode_list_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Entry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<Episode> sse_decode_list_episode(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Episode>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_episode(deserializer));
    }
    return ans_;
  }

  @protected
  List<ExtensionType> sse_decode_list_extension_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ExtensionType>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_extension_type(deserializer));
    }
    return ans_;
  }

  @protected
  List<ImageListAudio> sse_decode_list_image_list_audio(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ImageListAudio>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_image_list_audio(deserializer));
    }
    return ans_;
  }

  @protected
  List<Link> sse_decode_list_link(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Link>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_link(deserializer));
    }
    return ans_;
  }

  @protected
  List<MediaType> sse_decode_list_media_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MediaType>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_media_type(deserializer));
    }
    return ans_;
  }

  @protected
  List<Mp3Chapter> sse_decode_list_mp_3_chapter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Mp3Chapter>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_mp_3_chapter(deserializer));
    }
    return ans_;
  }

  @protected
  List<Paragraph> sse_decode_list_paragraph(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Paragraph>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_paragraph(deserializer));
    }
    return ans_;
  }

  @protected
  List<Permission> sse_decode_list_permission(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Permission>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_permission(deserializer));
    }
    return ans_;
  }

  @protected
  List<PopupAction> sse_decode_list_popup_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PopupAction>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_popup_action(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, Setting)> sse_decode_list_record_string_setting(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, Setting)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_setting(deserializer));
    }
    return ans_;
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<RemoteExtension> sse_decode_list_remote_extension(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RemoteExtension>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_remote_extension(deserializer));
    }
    return ans_;
  }

  @protected
  List<Subtitles> sse_decode_list_subtitles(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Subtitles>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_subtitles(deserializer));
    }
    return ans_;
  }

  @protected
  MediaType sse_decode_media_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return MediaType.values[inner];
  }

  @protected
  Mp3Chapter sse_decode_mp_3_chapter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_title = sse_decode_String(deserializer);
    var var_url = sse_decode_link(deserializer);
    return Mp3Chapter(title: var_title, url: var_url);
  }

  @protected
  Map<String, String>? sse_decode_opt_Map_String_String_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_Map_String_String_None(deserializer));
    } else {
      return null;
    }
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  CancelToken?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  CustomUI? sse_decode_opt_box_autoadd_custom_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_custom_ui(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Link? sse_decode_opt_box_autoadd_link(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_link(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SettingsUI? sse_decode_opt_box_autoadd_settings_ui(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_settings_ui(deserializer));
    } else {
      return null;
    }
  }

  @protected
  UIAction? sse_decode_opt_box_ui_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_ui_action(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<ExtensionType>? sse_decode_opt_list_extension_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_extension_type(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<ImageListAudio>? sse_decode_opt_list_image_list_audio(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_image_list_audio(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<MediaType>? sse_decode_opt_list_media_type(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_media_type(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Paragraph sse_decode_paragraph(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_content = sse_decode_String(deserializer);
        return Paragraph_Text(content: var_content);
      case 1:
        var var_ui = sse_decode_box_custom_ui(deserializer);
        return Paragraph_CustomUI(ui: var_ui);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Permission sse_decode_permission(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_path = sse_decode_String(deserializer);
        var var_write = sse_decode_bool(deserializer);
        return Permission_Storage(path: var_path, write: var_write);
      case 1:
        var var_domain = sse_decode_String(deserializer);
        return Permission_Network(domain: var_domain);
      case 2:
        return const Permission_ActionPopup();
      case 3:
        return const Permission_ArbitraryNetwork();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PopupAction sse_decode_popup_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_label = sse_decode_String(deserializer);
    var var_onclick = sse_decode_box_action(deserializer);
    return PopupAction(label: var_label, onclick: var_onclick);
  }

  @protected
  (String, Setting) sse_decode_record_string_setting(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_setting(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  ReleaseStatus sse_decode_release_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ReleaseStatus.values[inner];
  }

  @protected
  RemoteExtension sse_decode_remote_extension(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_extensionUrl = sse_decode_String(deserializer);
    var var_compatible = sse_decode_bool(deserializer);
    var var_data = sse_decode_extension_data(deserializer);
    return RemoteExtension(
        extensionUrl: var_extensionUrl,
        compatible: var_compatible,
        data: var_data);
  }

  @protected
  Setting sse_decode_setting(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_label = sse_decode_String(deserializer);
    var var_value = sse_decode_setting_value(deserializer);
    var var_default_ = sse_decode_setting_value(deserializer);
    var var_visible = sse_decode_bool(deserializer);
    var var_ui = sse_decode_opt_box_autoadd_settings_ui(deserializer);
    return Setting(
        label: var_label,
        value: var_value,
        default_: var_default_,
        visible: var_visible,
        ui: var_ui);
  }

  @protected
  SettingKind sse_decode_setting_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SettingKind.values[inner];
  }

  @protected
  SettingValue sse_decode_setting_value(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_data = sse_decode_String(deserializer);
        return SettingValue_String(data: var_data);
      case 1:
        var var_data = sse_decode_f_32(deserializer);
        return SettingValue_Number(data: var_data);
      case 2:
        var var_data = sse_decode_bool(deserializer);
        return SettingValue_Boolean(data: var_data);
      case 3:
        var var_data = sse_decode_list_String(deserializer);
        return SettingValue_StringList(data: var_data);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SettingsUI sse_decode_settings_ui(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return const SettingsUI_CheckBox();
      case 1:
        var var_min = sse_decode_f_64(deserializer);
        var var_max = sse_decode_f_64(deserializer);
        var var_step = sse_decode_i_32(deserializer);
        return SettingsUI_Slider(min: var_min, max: var_max, step: var_step);
      case 2:
        var var_options = sse_decode_list_dropdown_option(deserializer);
        return SettingsUI_Dropdown(options: var_options);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Source sse_decode_source(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_link = sse_decode_box_autoadd_link(deserializer);
        return Source_Epub(link: var_link);
      case 1:
        var var_link = sse_decode_box_autoadd_link(deserializer);
        return Source_Pdf(link: var_link);
      case 2:
        var var_links = sse_decode_list_link(deserializer);
        var var_audio = sse_decode_opt_list_image_list_audio(deserializer);
        return Source_Imagelist(links: var_links, audio: var_audio);
      case 3:
        var var_link = sse_decode_box_autoadd_link(deserializer);
        var var_sub = sse_decode_list_subtitles(deserializer);
        return Source_M3u8(link: var_link, sub: var_sub);
      case 4:
        var var_chapters = sse_decode_list_mp_3_chapter(deserializer);
        return Source_Mp3(chapters: var_chapters);
      case 5:
        var var_paragraphs = sse_decode_list_paragraph(deserializer);
        return Source_Paragraphlist(paragraphs: var_paragraphs);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SourceResult sse_decode_source_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_source = sse_decode_source(deserializer);
    var var_settings = sse_decode_Map_String_setting_None(deserializer);
    return SourceResult(source: var_source, settings: var_settings);
  }

  @protected
  Subtitles sse_decode_subtitles(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_title = sse_decode_String(deserializer);
    var var_url = sse_decode_link(deserializer);
    return Subtitles(title: var_title, url: var_url);
  }

  @protected
  TimestampType sse_decode_timestamp_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return TimestampType.values[inner];
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  UIAction sse_decode_ui_action(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_action = sse_decode_box_autoadd_action(deserializer);
        return UIAction_Action(action: var_action);
      case 1:
        var var_targetid = sse_decode_opt_String(deserializer);
        var var_event = sse_decode_String(deserializer);
        var var_placeholder =
            sse_decode_opt_box_autoadd_custom_ui(deserializer);
        return UIAction_SwapContent(
            targetid: var_targetid,
            event: var_event,
            placeholder: var_placeholder);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
      CancelToken raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as CancelTokenImpl).frbInternalCstEncode(move: true);
  }

  @protected
  int cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
      ProxyExtension raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyExtensionImpl).frbInternalCstEncode(move: true);
  }

  @protected
  int cst_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
      ProxyExtensionManager raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyExtensionManagerImpl).frbInternalCstEncode(move: true);
  }

  @protected
  int cst_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
      ProxyExtension raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyExtensionImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
      CancelToken raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as CancelTokenImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
      ManagerClient raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ManagerClientImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
      ProxyExtension raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyExtensionImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
      ProxyExtensionManager raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyExtensionManagerImpl).frbInternalCstEncode(move: false);
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
      CancelToken raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as CancelTokenImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
      ManagerClient raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ManagerClientImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
      ProxyExtension raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyExtensionImpl).frbInternalCstEncode();
  }

  @protected
  int cst_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
      ProxyExtensionManager raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
// ignore: invalid_use_of_internal_member
    return (raw as ProxyExtensionManagerImpl).frbInternalCstEncode();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_extension_type(ExtensionType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  double cst_encode_f_32(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  double cst_encode_f_64(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_media_type(MediaType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_release_status(ReleaseStatus raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_timestamp_type(TimestampType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          CancelToken self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CancelTokenImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
          ExtensionClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ExtensionClientImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          ManagerClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ManagerClientImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          ProxyExtension self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyExtensionImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
          ProxyExtensionManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyExtensionManagerImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          ProxyExtension self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyExtensionImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          CancelToken self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CancelTokenImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          ManagerClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ManagerClientImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          ProxyExtension self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyExtensionImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
          ProxyExtensionManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyExtensionManagerImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_String_Output_String_AnyhowException(
      FutureOr<String> Function(String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_String_Output_String_AnyhowException(self),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_String_String_Output_unit_AnyhowException(
      FutureOr<void> Function(String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_String_String_Output_unit_AnyhowException(self),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs__Output_String_AnyhowException(
      FutureOr<String> Function() self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs__Output_String_AnyhowException(self), serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_action_Output_unit_AnyhowException(
      FutureOr<void> Function(Action) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_action_Output_unit_AnyhowException(self),
        serializer);
  }

  @protected
  void
      sse_encode_DartFn_Inputs_extension_data_Output_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient_AnyhowException(
          FutureOr<ExtensionClient> Function(ExtensionData) self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_extension_data_Output_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient_AnyhowException(
            self),
        serializer);
  }

  @protected
  void
      sse_encode_DartFn_Inputs_permission_opt_String_Output_bool_AnyhowException(
          FutureOr<bool> Function(Permission, String?) self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_permission_opt_String_Output_bool_AnyhowException(
            self),
        serializer);
  }

  @protected
  void sse_encode_DartOpaque(Object self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_isize(
        PlatformPointerUtil.ptrToPlatformInt64(encodeDartOpaque(
            self, portManager.dartHandlerPort, generalizedFrbRustBinding)),
        serializer);
  }

  @protected
  void sse_encode_Map_String_String_None(
      Map<String, String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_string(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void sse_encode_Map_String_setting_None(
      Map<String, Setting> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_setting(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          CancelToken self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CancelTokenImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerExtensionClient(
          ExtensionClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ExtensionClientImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerManagerClient(
          ManagerClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ManagerClientImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          ProxyExtension self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyExtensionImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtensionManager(
          ProxyExtensionManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProxyExtensionManagerImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_action(Action self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Action_OpenBrowser(url: final url):
        sse_encode_i_32(0, serializer);
        sse_encode_String(url, serializer);
      case Action_Popup(
          title: final title,
          content: final content,
          actions: final actions
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_String(title, serializer);
        sse_encode_box_autoadd_custom_ui(content, serializer);
        sse_encode_list_popup_action(actions, serializer);
      case Action_Nav(title: final title, content: final content):
        sse_encode_i_32(2, serializer);
        sse_encode_String(title, serializer);
        sse_encode_box_autoadd_custom_ui(content, serializer);
      case Action_TriggerEvent(event: final event, data: final data):
        sse_encode_i_32(3, serializer);
        sse_encode_String(event, serializer);
        sse_encode_String(data, serializer);
    }
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_action(Action self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_action(self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          CancelToken self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
        self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_action(Action self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_action(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_custom_ui(
      CustomUI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_custom_ui(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_entry(Entry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entry(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_entry_activity(
      EntryActivity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entry_activity(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_entry_detailed(
      EntryDetailed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entry_detailed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_link(Link self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_link(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_permission(
      Permission self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_permission(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_remote_extension(
      RemoteExtension self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_remote_extension(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_setting(Setting self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_setting(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_setting_value(
      SettingValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_setting_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_settings_ui(
      SettingsUI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_settings_ui(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_source(Source self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_source(self, serializer);
  }

  @protected
  void sse_encode_box_custom_ui(CustomUI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_custom_ui(self, serializer);
  }

  @protected
  void sse_encode_box_ui_action(UIAction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_ui_action(self, serializer);
  }

  @protected
  void sse_encode_custom_ui(CustomUI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case CustomUI_Text(text: final text):
        sse_encode_i_32(0, serializer);
        sse_encode_String(text, serializer);
      case CustomUI_Image(
          image: final image,
          width: final width,
          height: final height
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_link(image, serializer);
        sse_encode_opt_box_autoadd_i_32(width, serializer);
        sse_encode_opt_box_autoadd_i_32(height, serializer);
      case CustomUI_Link(link: final link, label: final label):
        sse_encode_i_32(2, serializer);
        sse_encode_String(link, serializer);
        sse_encode_opt_String(label, serializer);
      case CustomUI_TimeStamp(
          timestamp: final timestamp,
          display: final display
        ):
        sse_encode_i_32(3, serializer);
        sse_encode_String(timestamp, serializer);
        sse_encode_timestamp_type(display, serializer);
      case CustomUI_EntryCard(entry: final entry):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_entry(entry, serializer);
      case CustomUI_Button(label: final label, onClick: final onClick):
        sse_encode_i_32(5, serializer);
        sse_encode_String(label, serializer);
        sse_encode_opt_box_ui_action(onClick, serializer);
      case CustomUI_InlineSetting(
          settingId: final settingId,
          onCommit: final onCommit
        ):
        sse_encode_i_32(6, serializer);
        sse_encode_String(settingId, serializer);
        sse_encode_opt_box_ui_action(onCommit, serializer);
      case CustomUI_Slot(id: final id, child: final child):
        sse_encode_i_32(7, serializer);
        sse_encode_String(id, serializer);
        sse_encode_box_custom_ui(child, serializer);
      case CustomUI_Column(children: final children):
        sse_encode_i_32(8, serializer);
        sse_encode_list_custom_ui(children, serializer);
      case CustomUI_Row(children: final children):
        sse_encode_i_32(9, serializer);
        sse_encode_list_custom_ui(children, serializer);
    }
  }

  @protected
  void sse_encode_dropdown_option(
      DropdownOption self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.label, serializer);
    sse_encode_String(self.value, serializer);
  }

  @protected
  void sse_encode_entry(Entry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_media_type(self.mediaType, serializer);
    sse_encode_opt_box_autoadd_link(self.cover, serializer);
    sse_encode_opt_list_String(self.author, serializer);
    sse_encode_opt_box_autoadd_f_32(self.rating, serializer);
    sse_encode_opt_box_autoadd_f_32(self.views, serializer);
    sse_encode_opt_box_autoadd_i_32(self.length, serializer);
  }

  @protected
  void sse_encode_entry_activity(EntryActivity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case EntryActivity_EpisodeActivity(progress: final progress):
        sse_encode_i_32(0, serializer);
        sse_encode_i_32(progress, serializer);
    }
  }

  @protected
  void sse_encode_entry_detailed(EntryDetailed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_list_String(self.titles, serializer);
    sse_encode_opt_list_String(self.author, serializer);
    sse_encode_opt_box_autoadd_custom_ui(self.ui, serializer);
    sse_encode_opt_Map_String_String_None(self.meta, serializer);
    sse_encode_media_type(self.mediaType, serializer);
    sse_encode_release_status(self.status, serializer);
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.language, serializer);
    sse_encode_opt_box_autoadd_link(self.cover, serializer);
    sse_encode_list_episode(self.episodes, serializer);
    sse_encode_opt_list_String(self.genres, serializer);
    sse_encode_opt_box_autoadd_f_32(self.rating, serializer);
    sse_encode_opt_box_autoadd_f_32(self.views, serializer);
    sse_encode_opt_box_autoadd_i_32(self.length, serializer);
  }

  @protected
  void sse_encode_entry_detailed_result(
      EntryDetailedResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_entry_detailed(self.entry, serializer);
    sse_encode_Map_String_setting_None(self.settings, serializer);
  }

  @protected
  void sse_encode_entry_list(EntryList self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_bool(self.hasnext, serializer);
    sse_encode_opt_box_autoadd_i_32(self.length, serializer);
    sse_encode_list_entry(self.content, serializer);
  }

  @protected
  void sse_encode_episode(Episode self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_opt_String(self.description, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_opt_box_autoadd_link(self.cover, serializer);
    sse_encode_opt_String(self.timestamp, serializer);
  }

  @protected
  void sse_encode_extension_data(ExtensionData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_opt_String(self.repo, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_opt_list_media_type(self.mediaType, serializer);
    sse_encode_opt_list_extension_type(self.extensionType, serializer);
    sse_encode_opt_String(self.version, serializer);
    sse_encode_opt_String(self.desc, serializer);
    sse_encode_list_String(self.author, serializer);
    sse_encode_opt_String(self.license, serializer);
    sse_encode_opt_list_String(self.tags, serializer);
    sse_encode_opt_box_autoadd_bool(self.nsfw, serializer);
    sse_encode_list_String(self.lang, serializer);
    sse_encode_opt_String(self.url, serializer);
    sse_encode_opt_String(self.icon, serializer);
  }

  @protected
  void sse_encode_extension_repo(ExtensionRepo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.id, serializer);
    sse_encode_list_remote_extension(self.extensions, serializer);
  }

  @protected
  void sse_encode_extension_type(ExtensionType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_image_list_audio(
      ImageListAudio self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_link(self.link, serializer);
    sse_encode_i_32(self.from, serializer);
    sse_encode_i_32(self.to, serializer);
  }

  @protected
  void sse_encode_isize(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_link(Link self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_opt_Map_String_String_None(self.header, serializer);
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          List<ProxyExtension> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProxyExtension(
          item, serializer);
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_custom_ui(
      List<CustomUI> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_custom_ui(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dropdown_option(
      List<DropdownOption> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dropdown_option(item, serializer);
    }
  }

  @protected
  void sse_encode_list_entry(List<Entry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_episode(List<Episode> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_episode(item, serializer);
    }
  }

  @protected
  void sse_encode_list_extension_type(
      List<ExtensionType> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_extension_type(item, serializer);
    }
  }

  @protected
  void sse_encode_list_image_list_audio(
      List<ImageListAudio> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_image_list_audio(item, serializer);
    }
  }

  @protected
  void sse_encode_list_link(List<Link> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_link(item, serializer);
    }
  }

  @protected
  void sse_encode_list_media_type(
      List<MediaType> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_media_type(item, serializer);
    }
  }

  @protected
  void sse_encode_list_mp_3_chapter(
      List<Mp3Chapter> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_mp_3_chapter(item, serializer);
    }
  }

  @protected
  void sse_encode_list_paragraph(
      List<Paragraph> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_paragraph(item, serializer);
    }
  }

  @protected
  void sse_encode_list_permission(
      List<Permission> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_permission(item, serializer);
    }
  }

  @protected
  void sse_encode_list_popup_action(
      List<PopupAction> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_popup_action(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_string_setting(
      List<(String, Setting)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_setting(item, serializer);
    }
  }

  @protected
  void sse_encode_list_record_string_string(
      List<(String, String)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_remote_extension(
      List<RemoteExtension> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_remote_extension(item, serializer);
    }
  }

  @protected
  void sse_encode_list_subtitles(
      List<Subtitles> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_subtitles(item, serializer);
    }
  }

  @protected
  void sse_encode_media_type(MediaType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_mp_3_chapter(Mp3Chapter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.title, serializer);
    sse_encode_link(self.url, serializer);
  }

  @protected
  void sse_encode_opt_Map_String_String_None(
      Map<String, String>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_Map_String_String_None(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          CancelToken? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCancelToken(
          self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_custom_ui(
      CustomUI? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_custom_ui(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_link(Link? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_link(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_settings_ui(
      SettingsUI? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_settings_ui(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_ui_action(UIAction? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_ui_action(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_String(
      List<String>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_extension_type(
      List<ExtensionType>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_extension_type(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_image_list_audio(
      List<ImageListAudio>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_image_list_audio(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_media_type(
      List<MediaType>? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_media_type(self, serializer);
    }
  }

  @protected
  void sse_encode_paragraph(Paragraph self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Paragraph_Text(content: final content):
        sse_encode_i_32(0, serializer);
        sse_encode_String(content, serializer);
      case Paragraph_CustomUI(ui: final ui):
        sse_encode_i_32(1, serializer);
        sse_encode_box_custom_ui(ui, serializer);
    }
  }

  @protected
  void sse_encode_permission(Permission self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Permission_Storage(path: final path, write: final write):
        sse_encode_i_32(0, serializer);
        sse_encode_String(path, serializer);
        sse_encode_bool(write, serializer);
      case Permission_Network(domain: final domain):
        sse_encode_i_32(1, serializer);
        sse_encode_String(domain, serializer);
      case Permission_ActionPopup():
        sse_encode_i_32(2, serializer);
      case Permission_ArbitraryNetwork():
        sse_encode_i_32(3, serializer);
    }
  }

  @protected
  void sse_encode_popup_action(PopupAction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.label, serializer);
    sse_encode_box_action(self.onclick, serializer);
  }

  @protected
  void sse_encode_record_string_setting(
      (String, Setting) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_setting(self.$2, serializer);
  }

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_release_status(ReleaseStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_remote_extension(
      RemoteExtension self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.extensionUrl, serializer);
    sse_encode_bool(self.compatible, serializer);
    sse_encode_extension_data(self.data, serializer);
  }

  @protected
  void sse_encode_setting(Setting self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.label, serializer);
    sse_encode_setting_value(self.value, serializer);
    sse_encode_setting_value(self.default_, serializer);
    sse_encode_bool(self.visible, serializer);
    sse_encode_opt_box_autoadd_settings_ui(self.ui, serializer);
  }

  @protected
  void sse_encode_setting_kind(SettingKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_setting_value(SettingValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SettingValue_String(data: final data):
        sse_encode_i_32(0, serializer);
        sse_encode_String(data, serializer);
      case SettingValue_Number(data: final data):
        sse_encode_i_32(1, serializer);
        sse_encode_f_32(data, serializer);
      case SettingValue_Boolean(data: final data):
        sse_encode_i_32(2, serializer);
        sse_encode_bool(data, serializer);
      case SettingValue_StringList(data: final data):
        sse_encode_i_32(3, serializer);
        sse_encode_list_String(data, serializer);
    }
  }

  @protected
  void sse_encode_settings_ui(SettingsUI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SettingsUI_CheckBox():
        sse_encode_i_32(0, serializer);
      case SettingsUI_Slider(min: final min, max: final max, step: final step):
        sse_encode_i_32(1, serializer);
        sse_encode_f_64(min, serializer);
        sse_encode_f_64(max, serializer);
        sse_encode_i_32(step, serializer);
      case SettingsUI_Dropdown(options: final options):
        sse_encode_i_32(2, serializer);
        sse_encode_list_dropdown_option(options, serializer);
    }
  }

  @protected
  void sse_encode_source(Source self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Source_Epub(link: final link):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_link(link, serializer);
      case Source_Pdf(link: final link):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_link(link, serializer);
      case Source_Imagelist(links: final links, audio: final audio):
        sse_encode_i_32(2, serializer);
        sse_encode_list_link(links, serializer);
        sse_encode_opt_list_image_list_audio(audio, serializer);
      case Source_M3u8(link: final link, sub: final sub):
        sse_encode_i_32(3, serializer);
        sse_encode_box_autoadd_link(link, serializer);
        sse_encode_list_subtitles(sub, serializer);
      case Source_Mp3(chapters: final chapters):
        sse_encode_i_32(4, serializer);
        sse_encode_list_mp_3_chapter(chapters, serializer);
      case Source_Paragraphlist(paragraphs: final paragraphs):
        sse_encode_i_32(5, serializer);
        sse_encode_list_paragraph(paragraphs, serializer);
    }
  }

  @protected
  void sse_encode_source_result(SourceResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_source(self.source, serializer);
    sse_encode_Map_String_setting_None(self.settings, serializer);
  }

  @protected
  void sse_encode_subtitles(Subtitles self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.title, serializer);
    sse_encode_link(self.url, serializer);
  }

  @protected
  void sse_encode_timestamp_type(TimestampType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_ui_action(UIAction self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case UIAction_Action(action: final action):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_action(action, serializer);
      case UIAction_SwapContent(
          targetid: final targetid,
          event: final event,
          placeholder: final placeholder
        ):
        sse_encode_i_32(1, serializer);
        sse_encode_opt_String(targetid, serializer);
        sse_encode_String(event, serializer);
        sse_encode_opt_box_autoadd_custom_ui(placeholder, serializer);
    }
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}

@sealed
class CancelTokenImpl extends RustOpaque implements CancelToken {
  // Not to be used by end users
  CancelTokenImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  CancelTokenImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_CancelToken,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_CancelToken,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_CancelTokenPtr,
  );

  Future<void> cancel() => RustLib.instance.api.crateApiCancelCancelTokenCancel(
        that: this,
      );

  Future<CancelToken> getChild() =>
      RustLib.instance.api.crateApiCancelCancelTokenGetChild(
        that: this,
      );

  Future<bool> isCancelled() =>
      RustLib.instance.api.crateApiCancelCancelTokenIsCancelled(
        that: this,
      );
}

@sealed
class ExtensionClientImpl extends RustOpaque implements ExtensionClient {
  // Not to be used by end users
  ExtensionClientImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ExtensionClientImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ExtensionClient,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ExtensionClient,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ExtensionClientPtr,
  );
}

@sealed
class ManagerClientImpl extends RustOpaque implements ManagerClient {
  // Not to be used by end users
  ManagerClientImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ManagerClientImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ManagerClient,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ManagerClient,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ManagerClientPtr,
  );
}

@sealed
class ProxyExtensionImpl extends RustOpaque implements ProxyExtension {
  // Not to be used by end users
  ProxyExtensionImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ProxyExtensionImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ProxyExtension,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ProxyExtension,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ProxyExtensionPtr,
  );

  Future<EntryList> browse({required int page, CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionBrowse(
          that: this, page: page, token: token);

  Future<EntryDetailedResult> detail(
          {required String entryid,
          required Map<String, Setting> settings,
          CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionDetail(
          that: this, entryid: entryid, settings: settings, token: token);

  Future<bool> fromurl({required String url, CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionFromurl(
          that: this, url: url, token: token);

  Future<ExtensionData> getExtensionData() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionGetExtensionData(
        that: this,
      );

  Future<List<Permission>> getPermissions() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionGetPermissions(
        that: this,
      );

  Future<Setting> getSetting({required String id, required SettingKind kind}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionGetSetting(
          that: this, id: id, kind: kind);

  Future<List<String>> getSettingIds({required SettingKind kind}) =>
      RustLib.instance.api
          .crateApiExtensionProxyExtensionGetSettingIds(that: this, kind: kind);

  Future<Map<String, Setting>> getSettings({required SettingKind kind}) =>
      RustLib.instance.api
          .crateApiExtensionProxyExtensionGetSettings(that: this, kind: kind);

  Future<bool> hasPermission({required Permission permission}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionHasPermission(
          that: this, permission: permission);

  Future<bool> isEnabled() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionIsEnabled(
        that: this,
      );

  Future<EntryDetailedResult> mapEntry(
          {required EntryDetailed entry,
          required Map<String, Setting> settings,
          CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionMapEntry(
          that: this, entry: entry, settings: settings, token: token);

  Future<SourceResult> mapSource(
          {required Source source,
          required Map<String, Setting> settings,
          CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionMapSource(
          that: this, source: source, settings: settings, token: token);

  Future<void> mergeSettingDefinition(
          {required String id,
          required SettingKind kind,
          required Setting definition}) =>
      RustLib.instance.api
          .crateApiExtensionProxyExtensionMergeSettingDefinition(
              that: this, id: id, kind: kind, definition: definition);

  Future<void> onEntryActivity(
          {required EntryActivity activity,
          required EntryDetailed entry,
          required Map<String, Setting> settings,
          CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionOnEntryActivity(
          that: this,
          activity: activity,
          entry: entry,
          settings: settings,
          token: token);

  Future<void> reload() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionReload(
        that: this,
      );

  Future<void> removePermission({required Permission permission}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionRemovePermission(
          that: this, permission: permission);

  Future<void> removeSetting({required String id, required SettingKind kind}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionRemoveSetting(
          that: this, id: id, kind: kind);

  Future<EntryList> search(
          {required int page, required String filter, CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionSearch(
          that: this, page: page, filter: filter, token: token);

  Future<void> setEnabled({required bool enabled}) => RustLib.instance.api
      .crateApiExtensionProxyExtensionSetEnabled(that: this, enabled: enabled);

  Future<void> setSetting(
          {required String id,
          required SettingKind kind,
          required SettingValue value}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionSetSetting(
          that: this, id: id, kind: kind, value: value);

  Future<SourceResult> source(
          {required String epid,
          required Map<String, Setting> settings,
          CancelToken? token}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionSource(
          that: this, epid: epid, settings: settings, token: token);
}

@sealed
class ProxyExtensionManagerImpl extends RustOpaque
    implements ProxyExtensionManager {
  // Not to be used by end users
  ProxyExtensionManagerImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ProxyExtensionManagerImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_ProxyExtensionManager,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_ProxyExtensionManager,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_ProxyExtensionManagerPtr,
  );

  Future<List<ProxyExtension>> getExtensions() =>
      RustLib.instance.api.crateApiExtensionProxyExtensionManagerGetExtensions(
        that: this,
      );

  Future<ExtensionRepo> getRepo({required String url}) => RustLib.instance.api
      .crateApiExtensionProxyExtensionManagerGetRepo(that: this, url: url);

  Future<ProxyExtension> install({required RemoteExtension location}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionManagerInstall(
          that: this, location: location);

  Future<ProxyExtension> installSingle({required String url}) =>
      RustLib.instance.api.crateApiExtensionProxyExtensionManagerInstallSingle(
          that: this, url: url);

  Future<void> uninstall({required ProxyExtension ext}) => RustLib.instance.api
      .crateApiExtensionProxyExtensionManagerUninstall(that: this, ext: ext);
}
