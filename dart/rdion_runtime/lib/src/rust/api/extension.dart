// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

import 'dart:convert';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import '../third_party/dion_runtime/data/action.dart';
import '../third_party/dion_runtime/data/activity.dart';
import '../third_party/dion_runtime/data/custom_ui.dart';
import '../third_party/dion_runtime/data/extension.dart';
import '../third_party/dion_runtime/data/extension_repo.dart';
import '../third_party/dion_runtime/data/permission.dart';
import '../third_party/dion_runtime/data/settings.dart';
import '../third_party/dion_runtime/data/source.dart';
import 'cancel.dart';
import 'client.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProxyAdapter>>
abstract class ProxyAdapter implements RustOpaqueInterface {
  Future<RemoteExtensionResult> browseRepo(
      {required ExtensionRepo repo, required int page});

  Future<List<ProxyExtension>> getExtensions();

  Future<ExtensionRepo> getRepo({required String url});

  static Future<ProxyAdapter> initDion({required ManagerClient client}) =>
      RustLib.instance.api
          .crateApiExtensionProxyAdapterInitDion(client: client);

  Future<ProxyExtension> install({required String location});

  Future<void> uninstall({required ProxyExtension ext});
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ProxyExtension>>
abstract class ProxyExtension implements RustOpaqueInterface {
  Future<EntryList> browse({required int page, CancelToken? token});

  Future<EntryDetailedResult> detail(
      {required EntryId entryid,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<EventData?> event(
      {required EventResult event, CancellationToken? token});

  Future<ExtensionData> getExtensionData();

  Future<List<Permission>> getPermissions();

  Future<Setting> getSetting({required String id, required SettingKind kind});

  Future<List<String>> getSettingIds({required SettingKind kind});

  Future<Map<String, Setting>> getSettings({required SettingKind kind});

  Future<bool> handleUrl({required String url, CancelToken? token});

  Future<bool> hasPermission({required Permission permission});

  Future<bool> isEnabled();

  Future<EntryDetailedResult> mapEntry(
      {required EntryDetailed entry,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<SourceResult> mapSource(
      {required Source source,
      required EpisodeId epid,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<void> mergeSettingDefinition(
      {required String id,
      required SettingKind kind,
      required Setting definition});

  Future<void> onEntryActivity(
      {required EntryActivity activity,
      required EntryDetailed entry,
      required Map<String, Setting> settings,
      CancelToken? token});

  Future<void> reload();

  Future<void> removePermission({required Permission permission});

  Future<void> removeSetting({required String id, required SettingKind kind});

  Future<EntryList> search(
      {required int page, required String filter, CancelToken? token});

  Future<void> setEnabled({required bool enabled});

  Future<void> setSetting(
      {required String id,
      required SettingKind kind,
      required SettingValue value});

  Future<SourceResult> source(
      {required EpisodeId epid,
      required Map<String, Setting> settings,
      CancelToken? token});
}
