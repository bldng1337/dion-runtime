// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../third_party/dion_runtime/datastructs.dart';
import '../third_party/dion_runtime/jsextension.dart';
import '../third_party/dion_runtime/permission.dart';
import '../third_party/dion_runtime/settings.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `new`
// These functions are ignored because they have generic arguments: `request`
// These types are ignored because they are not used by any `pub` functions: `PermissionSink`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`, `into`

Stream<PermissionRequest> internalSetPermissionRequestListener() =>
    RustLib.instance.api.crateApiSimpleInternalSetPermissionRequestListener();

Future<void> internalSendPermissionRequestAnswer({required bool answer}) =>
    RustLib.instance.api
        .crateApiSimpleInternalSendPermissionRequestAnswer(answer: answer);

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<CancelToken>>
abstract class CancelToken implements RustOpaqueInterface {
  factory CancelToken() => RustLib.instance.api.crateApiSimpleCancelTokenNew();
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExtensionManagerProxy>>
abstract class ExtensionManagerProxy implements RustOpaqueInterface {
  Future<void> addFromFile({required String path});

  Future<List<ExtensionProxy>> iter();

  factory ExtensionManagerProxy() =>
      RustLib.instance.api.crateApiSimpleExtensionManagerProxyNew();
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ExtensionProxy>>
abstract class ExtensionProxy implements RustOpaqueInterface {
  Future<List<Entry>> browse(
      {required PlatformInt64 page, required Sort sort, CancelToken? token});

  Future<ExtensionData> data();

  Future<EntryDetailed> detail({required Entry entry, CancelToken? token});

  Future<void> enable();

  Future<Entry?> fromurl({required String url, CancelToken? token});

  Future<Setting> getSetting({required String name});

  Future<bool> isEnabled();

  Future<List<Permission>> permissionsIter();

  Future<void> removePermissions({required Permission permission});

  Future<List<Entry>> search(
      {required PlatformInt64 page,
      required String filter,
      CancelToken? token});

  Future<void> setSetting(
      {required String name, required Settingvalue setting});

  Future<List<String>> settingIdsIter();

  Future<Source> source({required Episode ep, CancelToken? token});
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<QueueStore>>
abstract class QueueStore implements RustOpaqueInterface {
  static Future<QueueStore> default_() =>
      RustLib.instance.api.crateApiSimpleQueueStoreDefault();
}

class PermissionRequest {
  final Permission permission;
  final String? msg;

  const PermissionRequest({
    required this.permission,
    this.msg,
  });

  @override
  int get hashCode => permission.hashCode ^ msg.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PermissionRequest &&
          runtimeType == other.runtimeType &&
          permission == other.permission &&
          msg == other.msg;
}
