// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

import 'dart:convert';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'settings.dart';
part 'datastructs.freezed.dart';
part 'datastructs.g.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

@freezed
sealed class Action with _$Action {
  const Action._();

  const factory Action.openBrowser({
    required String url,
  }) = Action_OpenBrowser;
  const factory Action.popup({
    required String title,
    required CustomUI content,
    required List<PopupAction> actions,
  }) = Action_Popup;
  const factory Action.nav({
    required String title,
    required CustomUI content,
  }) = Action_Nav;
  const factory Action.triggerEvent({
    required String event,
    required String data,
  }) = Action_TriggerEvent;

  factory Action.fromJson(Map<String, dynamic> json) => _$ActionFromJson(json);
}

@freezed
sealed class CustomUI with _$CustomUI {
  const CustomUI._();

  const factory CustomUI.text({
    required String text,
  }) = CustomUI_Text;
  const factory CustomUI.image({
    required Link image,
    int? width,
    int? height,
  }) = CustomUI_Image;
  const factory CustomUI.link({
    required String link,
    String? label,
  }) = CustomUI_Link;
  const factory CustomUI.timeStamp({
    required String timestamp,
    required TimestampType display,
  }) = CustomUI_TimeStamp;
  const factory CustomUI.entryCard({
    required Entry entry,
  }) = CustomUI_EntryCard;
  const factory CustomUI.button({
    required String label,
    UIAction? onClick,
  }) = CustomUI_Button;
  const factory CustomUI.inlineSetting({
    required String settingId,
    UIAction? onCommit,
  }) = CustomUI_InlineSetting;
  const factory CustomUI.slot({
    required String id,
    required CustomUI child,
  }) = CustomUI_Slot;
  const factory CustomUI.column({
    required List<CustomUI> children,
  }) = CustomUI_Column;
  const factory CustomUI.row({
    required List<CustomUI> children,
  }) = CustomUI_Row;

  factory CustomUI.fromJson(Map<String, dynamic> json) =>
      _$CustomUIFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class Entry with _$Entry {
  const Entry._();
  const factory Entry({
    required String id,
    required String url,
    required String title,
    required MediaType mediaType,
    Link? cover,
    List<String>? author,
    double? rating,
    double? views,
    int? length,
  }) = _Entry;
  static Future<Entry> default_() =>
      RustLib.instance.api.dionRuntimeDatastructsEntryDefault();

  factory Entry.fromJson(Map<String, dynamic> json) => _$EntryFromJson(json);
}

@freezed
sealed class EntryActivity with _$EntryActivity {
  const EntryActivity._();

  const factory EntryActivity.episodeActivity({
    required int progress,
  }) = EntryActivity_EpisodeActivity;

  factory EntryActivity.fromJson(Map<String, dynamic> json) =>
      _$EntryActivityFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class EntryDetailed with _$EntryDetailed {
  const EntryDetailed._();
  const factory EntryDetailed({
    required String id,
    required String url,
    required List<String> titles,
    List<String>? author,
    CustomUI? ui,
    Map<String, String>? meta,
    required MediaType mediaType,
    required ReleaseStatus status,
    required String description,
    required String language,
    Link? cover,
    required List<Episode> episodes,
    List<String>? genres,
    double? rating,
    double? views,
    int? length,
  }) = _EntryDetailed;
  static Future<EntryDetailed> default_() =>
      RustLib.instance.api.dionRuntimeDatastructsEntryDetailedDefault();

  factory EntryDetailed.fromJson(Map<String, dynamic> json) =>
      _$EntryDetailedFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class EntryDetailedResult with _$EntryDetailedResult {
  const EntryDetailedResult._();
  const factory EntryDetailedResult({
    required EntryDetailed entry,
    required Map<String, Setting> settings,
  }) = _EntryDetailedResult;
  static Future<EntryDetailedResult> default_() =>
      RustLib.instance.api.dionRuntimeDatastructsEntryDetailedResultDefault();

  factory EntryDetailedResult.fromJson(Map<String, dynamic> json) =>
      _$EntryDetailedResultFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class EntryList with _$EntryList {
  const EntryList._();
  const factory EntryList({
    bool? hasnext,
    int? length,
    required List<Entry> content,
  }) = _EntryList;
  static Future<EntryList> default_() =>
      RustLib.instance.api.dionRuntimeDatastructsEntryListDefault();

  factory EntryList.fromJson(Map<String, dynamic> json) =>
      _$EntryListFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class Episode with _$Episode {
  const Episode._();
  const factory Episode({
    required String id,
    required String name,
    String? description,
    required String url,
    Link? cover,
    String? timestamp,
  }) = _Episode;
  static Future<Episode> default_() =>
      RustLib.instance.api.dionRuntimeDatastructsEpisodeDefault();

  factory Episode.fromJson(Map<String, dynamic> json) =>
      _$EpisodeFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class ExtensionData with _$ExtensionData {
  const ExtensionData._();
  const factory ExtensionData({
    required String id,
    String? repo,
    required String name,
    List<MediaType>? mediaType,
    List<ExtensionType>? extensionType,
    String? version,
    String? desc,
    required List<String> author,
    String? license,
    List<String>? tags,
    bool? nsfw,
    required List<String> lang,
    String? url,
    String? icon,
  }) = _ExtensionData;
  static Future<ExtensionData> default_() =>
      RustLib.instance.api.dionRuntimeDatastructsExtensionDataDefault();

  factory ExtensionData.fromJson(Map<String, dynamic> json) =>
      _$ExtensionDataFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class ExtensionRepo with _$ExtensionRepo {
  const ExtensionRepo._();
  const factory ExtensionRepo({
    required String name,
    required String description,
    required String id,
    required List<RemoteExtension> extensions,
  }) = _ExtensionRepo;
  static Future<ExtensionRepo> default_() =>
      RustLib.instance.api.dionRuntimeDatastructsExtensionRepoDefault();

  factory ExtensionRepo.fromJson(Map<String, dynamic> json) =>
      _$ExtensionRepoFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
enum ExtensionType {
  sourceProvider,
  urlResolve,
  sourceProcessor,
  entryExtension,
  ;
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class ImageListAudio with _$ImageListAudio {
  const factory ImageListAudio({
    required Link link,
    required int from,
    required int to,
  }) = _ImageListAudio;

  factory ImageListAudio.fromJson(Map<String, dynamic> json) =>
      _$ImageListAudioFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class Link with _$Link {
  const Link._();
  const factory Link({
    required String url,
    Map<String, String>? header,
  }) = _Link;
  static Future<Link> default_() =>
      RustLib.instance.api.dionRuntimeDatastructsLinkDefault();

  factory Link.fromJson(Map<String, dynamic> json) => _$LinkFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
enum MediaType {
  video,
  comic,
  audio,
  book,
  unknown,
  ;

  static Future<MediaType> default_() =>
      RustLib.instance.api.dionRuntimeDatastructsMediaTypeDefault();
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class Mp3Chapter with _$Mp3Chapter {
  const factory Mp3Chapter({
    required String title,
    required Link url,
  }) = _Mp3Chapter;

  factory Mp3Chapter.fromJson(Map<String, dynamic> json) =>
      _$Mp3ChapterFromJson(json);
}

@freezed
sealed class Paragraph with _$Paragraph {
  const Paragraph._();

  const factory Paragraph.text({
    required String content,
  }) = Paragraph_Text;
  const factory Paragraph.customUi({
    required CustomUI ui,
  }) = Paragraph_CustomUI;

  factory Paragraph.fromJson(Map<String, dynamic> json) =>
      _$ParagraphFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class PopupAction with _$PopupAction {
  const factory PopupAction({
    required String label,
    required Action onclick,
  }) = _PopupAction;

  factory PopupAction.fromJson(Map<String, dynamic> json) =>
      _$PopupActionFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
enum ReleaseStatus {
  releasing,
  complete,
  unknown,
  ;

  static Future<ReleaseStatus> default_() =>
      RustLib.instance.api.dionRuntimeDatastructsReleaseStatusDefault();
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class RemoteExtension with _$RemoteExtension {
  const RemoteExtension._();
  const factory RemoteExtension({
    required String extensionUrl,
    required bool compatible,
    required ExtensionData data,
  }) = _RemoteExtension;
  static Future<RemoteExtension> default_() =>
      RustLib.instance.api.dionRuntimeDatastructsRemoteExtensionDefault();

  factory RemoteExtension.fromJson(Map<String, dynamic> json) =>
      _$RemoteExtensionFromJson(json);
}

@freezed
sealed class Source with _$Source {
  const Source._();

  const factory Source.epub({
    required Link link,
  }) = Source_Epub;
  const factory Source.pdf({
    required Link link,
  }) = Source_Pdf;
  const factory Source.imagelist({
    required List<Link> links,
    List<ImageListAudio>? audio,
  }) = Source_Imagelist;
  const factory Source.m3U8({
    required Link link,
    required List<Subtitles> sub,
  }) = Source_M3u8;
  const factory Source.mp3({
    required List<Mp3Chapter> chapters,
  }) = Source_Mp3;
  const factory Source.paragraphlist({
    required List<Paragraph> paragraphs,
  }) = Source_Paragraphlist;

  factory Source.fromJson(Map<String, dynamic> json) => _$SourceFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class SourceResult with _$SourceResult {
  const factory SourceResult({
    required Source source,
    required Map<String, Setting> settings,
  }) = _SourceResult;

  factory SourceResult.fromJson(Map<String, dynamic> json) =>
      _$SourceResultFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
@freezed
sealed class Subtitles with _$Subtitles {
  const factory Subtitles({
    required String title,
    required Link url,
  }) = _Subtitles;

  factory Subtitles.fromJson(Map<String, dynamic> json) =>
      _$SubtitlesFromJson(json);
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:json_serializable
enum TimestampType {
  relative,
  absolute,
  ;

  static Future<TimestampType> default_() =>
      RustLib.instance.api.dionRuntimeDatastructsTimestampTypeDefault();
}

@freezed
sealed class UIAction with _$UIAction {
  const UIAction._();

  const factory UIAction.action({
    required Action action,
  }) = UIAction_Action;
  const factory UIAction.swapContent({
    String? targetid,
    required String event,
    CustomUI? placeholder,
  }) = UIAction_SwapContent;

  factory UIAction.fromJson(Map<String, dynamic> json) =>
      _$UIActionFromJson(json);
}
