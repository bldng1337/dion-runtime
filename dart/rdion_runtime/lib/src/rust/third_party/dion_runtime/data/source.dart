// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

import 'dart:convert';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import 'action.dart';
import 'custom_ui.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'settings.dart';
part 'source.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `hash`, `hash`

/// flutter_rust_bridge:non_opaque
class Entry {
  final List<EntryId> id;
  final String url;
  final String title;
  final MediaType mediaType;
  final Link? cover;
  final List<String>? author;
  final double? rating;
  final double? views;
  final int? length;

  const Entry({
    required this.id,
    required this.url,
    required this.title,
    required this.mediaType,
    this.cover,
    this.author,
    this.rating,
    this.views,
    this.length,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      url.hashCode ^
      title.hashCode ^
      mediaType.hashCode ^
      cover.hashCode ^
      author.hashCode ^
      rating.hashCode ^
      views.hashCode ^
      length.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Entry &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          url == other.url &&
          title == other.title &&
          mediaType == other.mediaType &&
          cover == other.cover &&
          author == other.author &&
          rating == other.rating &&
          views == other.views &&
          length == other.length;
}

/// flutter_rust_bridge:non_opaque
class EntryDetailed {
  final List<EntryId> id;
  final String url;
  final List<String> titles;
  final List<String>? author;
  final CustomUI? ui;
  final Map<String, String>? meta;
  final MediaType mediaType;
  final ReleaseStatus status;
  final String description;
  final String language;
  final Link? cover;
  final List<Episode> episodes;
  final List<String>? genres;
  final double? rating;
  final double? views;
  final int? length;

  const EntryDetailed({
    required this.id,
    required this.url,
    required this.titles,
    this.author,
    this.ui,
    this.meta,
    required this.mediaType,
    required this.status,
    required this.description,
    required this.language,
    this.cover,
    required this.episodes,
    this.genres,
    this.rating,
    this.views,
    this.length,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      url.hashCode ^
      titles.hashCode ^
      author.hashCode ^
      ui.hashCode ^
      meta.hashCode ^
      mediaType.hashCode ^
      status.hashCode ^
      description.hashCode ^
      language.hashCode ^
      cover.hashCode ^
      episodes.hashCode ^
      genres.hashCode ^
      rating.hashCode ^
      views.hashCode ^
      length.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EntryDetailed &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          url == other.url &&
          titles == other.titles &&
          author == other.author &&
          ui == other.ui &&
          meta == other.meta &&
          mediaType == other.mediaType &&
          status == other.status &&
          description == other.description &&
          language == other.language &&
          cover == other.cover &&
          episodes == other.episodes &&
          genres == other.genres &&
          rating == other.rating &&
          views == other.views &&
          length == other.length;
}

/// flutter_rust_bridge:non_opaque
class EntryDetailedResult {
  final EntryDetailed entry;
  final Map<String, Setting> settings;

  const EntryDetailedResult({
    required this.entry,
    required this.settings,
  });

  @override
  int get hashCode => entry.hashCode ^ settings.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EntryDetailedResult &&
          runtimeType == other.runtimeType &&
          entry == other.entry &&
          settings == other.settings;
}

/// flutter_rust_bridge:non_opaque
class EntryId {
  final String uid;
  final String? iddata;
  final String idType;

  const EntryId({
    required this.uid,
    this.iddata,
    required this.idType,
  });

  @override
  int get hashCode => uid.hashCode ^ iddata.hashCode ^ idType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EntryId &&
          runtimeType == other.runtimeType &&
          uid == other.uid &&
          iddata == other.iddata &&
          idType == other.idType;
}

/// flutter_rust_bridge:non_opaque
class EntryList {
  final bool? hasnext;
  final int? length;
  final List<Entry> content;

  const EntryList({
    this.hasnext,
    this.length,
    required this.content,
  });

  static Future<EntryList> default_() =>
      RustLib.instance.api.dionRuntimeDataSourceEntryListDefault();

  @override
  int get hashCode => hasnext.hashCode ^ length.hashCode ^ content.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EntryList &&
          runtimeType == other.runtimeType &&
          hasnext == other.hasnext &&
          length == other.length &&
          content == other.content;
}

/// flutter_rust_bridge:non_opaque
class Episode {
  final List<EpisodeId> id;
  final String name;
  final String? description;
  final String url;
  final Link? cover;
  final String? timestamp;

  const Episode({
    required this.id,
    required this.name,
    this.description,
    required this.url,
    this.cover,
    this.timestamp,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      description.hashCode ^
      url.hashCode ^
      cover.hashCode ^
      timestamp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Episode &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          description == other.description &&
          url == other.url &&
          cover == other.cover &&
          timestamp == other.timestamp;
}

/// flutter_rust_bridge:non_opaque
class EpisodeId {
  final String uid;
  final String? iddata;
  final String idType;

  const EpisodeId({
    required this.uid,
    this.iddata,
    required this.idType,
  });

  @override
  int get hashCode => uid.hashCode ^ iddata.hashCode ^ idType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is EpisodeId &&
          runtimeType == other.runtimeType &&
          uid == other.uid &&
          iddata == other.iddata &&
          idType == other.idType;
}

/// flutter_rust_bridge:non_opaque
class ImageListAudio {
  final Link link;
  final int from;
  final int to;

  const ImageListAudio({
    required this.link,
    required this.from,
    required this.to,
  });

  @override
  int get hashCode => link.hashCode ^ from.hashCode ^ to.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ImageListAudio &&
          runtimeType == other.runtimeType &&
          link == other.link &&
          from == other.from &&
          to == other.to;
}

/// flutter_rust_bridge:non_opaque
class Link {
  final String url;
  final Map<String, String>? header;

  const Link({
    required this.url,
    this.header,
  });

  static Future<Link> default_() =>
      RustLib.instance.api.dionRuntimeDataSourceLinkDefault();

  @override
  int get hashCode => url.hashCode ^ header.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Link &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          header == other.header;
}

/// flutter_rust_bridge:non_opaque
enum MediaType {
  video,
  comic,
  audio,
  book,
  unknown,
  ;

  static Future<MediaType> default_() =>
      RustLib.instance.api.dionRuntimeDataSourceMediaTypeDefault();
}

/// flutter_rust_bridge:non_opaque
class Mp3Chapter {
  final String title;
  final Link url;

  const Mp3Chapter({
    required this.title,
    required this.url,
  });

  @override
  int get hashCode => title.hashCode ^ url.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Mp3Chapter &&
          runtimeType == other.runtimeType &&
          title == other.title &&
          url == other.url;
}

@freezed
sealed class Paragraph with _$Paragraph {
  const Paragraph._();

  const factory Paragraph.text({
    required String content,
  }) = Paragraph_Text;
  const factory Paragraph.customUi({
    required CustomUI ui,
  }) = Paragraph_CustomUI;
}

/// flutter_rust_bridge:non_opaque
enum ReleaseStatus {
  releasing,
  complete,
  unknown,
  ;

  static Future<ReleaseStatus> default_() =>
      RustLib.instance.api.dionRuntimeDataSourceReleaseStatusDefault();
}

@freezed
sealed class Source with _$Source {
  const Source._();

  const factory Source.epub({
    required Link link,
  }) = Source_Epub;
  const factory Source.pdf({
    required Link link,
  }) = Source_Pdf;
  const factory Source.imagelist({
    required List<Link> links,
    List<ImageListAudio>? audio,
  }) = Source_Imagelist;
  const factory Source.m3U8({
    required Link link,
    required List<Subtitles> sub,
  }) = Source_M3u8;
  const factory Source.mp3({
    required List<Mp3Chapter> chapters,
  }) = Source_Mp3;
  const factory Source.paragraphlist({
    required List<Paragraph> paragraphs,
  }) = Source_Paragraphlist;
}

/// flutter_rust_bridge:non_opaque
class SourceResult {
  final Source source;
  final Map<String, Setting> settings;

  const SourceResult({
    required this.source,
    required this.settings,
  });

  @override
  int get hashCode => source.hashCode ^ settings.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SourceResult &&
          runtimeType == other.runtimeType &&
          source == other.source &&
          settings == other.settings;
}

/// flutter_rust_bridge:non_opaque
enum SourceType {
  epub,
  pdf,
  imagelist,
  m3U8,
  mp3,
  paragraphlist,
  ;
}

/// flutter_rust_bridge:non_opaque
class Subtitles {
  final String title;
  final Link url;

  const Subtitles({
    required this.title,
    required this.url,
  });

  @override
  int get hashCode => title.hashCode ^ url.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Subtitles &&
          runtimeType == other.runtimeType &&
          title == other.title &&
          url == other.url;
}
