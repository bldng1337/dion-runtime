// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

import 'dart:convert';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'source.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:unignore
class ExtensionRepo {
  final String remoteId;
  final String name;
  final String description;
  final String url;

  const ExtensionRepo({
    required this.remoteId,
    required this.name,
    required this.description,
    required this.url,
  });

  static Future<ExtensionRepo> default_() =>
      RustLib.instance.api.dionRuntimeDataExtensionRepoExtensionRepoDefault();

  @override
  int get hashCode =>
      remoteId.hashCode ^ name.hashCode ^ description.hashCode ^ url.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ExtensionRepo &&
          runtimeType == other.runtimeType &&
          remoteId == other.remoteId &&
          name == other.name &&
          description == other.description &&
          url == other.url;
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:unignore
class RemoteExtension {
  final String remoteId;
  final String id;
  final String name;
  final String url;
  final Link? cover;
  final String version;
  final bool compatible;

  const RemoteExtension({
    required this.remoteId,
    required this.id,
    required this.name,
    required this.url,
    this.cover,
    required this.version,
    required this.compatible,
  });

  static Future<RemoteExtension> default_() =>
      RustLib.instance.api.dionRuntimeDataExtensionRepoRemoteExtensionDefault();

  @override
  int get hashCode =>
      remoteId.hashCode ^
      id.hashCode ^
      name.hashCode ^
      url.hashCode ^
      cover.hashCode ^
      version.hashCode ^
      compatible.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RemoteExtension &&
          runtimeType == other.runtimeType &&
          remoteId == other.remoteId &&
          id == other.id &&
          name == other.name &&
          url == other.url &&
          cover == other.cover &&
          version == other.version &&
          compatible == other.compatible;
}

/// flutter_rust_bridge:non_opaque
/// flutter_rust_bridge:unignore
class RemoteExtensionResult {
  final List<RemoteExtension> content;
  final bool? hasnext;
  final int? length;

  const RemoteExtensionResult({
    required this.content,
    this.hasnext,
    this.length,
  });

  static Future<RemoteExtensionResult> default_() => RustLib.instance.api
      .dionRuntimeDataExtensionRepoRemoteExtensionResultDefault();

  @override
  int get hashCode => content.hashCode ^ hasnext.hashCode ^ length.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RemoteExtensionResult &&
          runtimeType == other.runtimeType &&
          content == other.content &&
          hasnext == other.hasnext &&
          length == other.length;
}
